// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: walletunlocker.proto
// Protobuf C++ Version: 5.28.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_walletunlocker_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_walletunlocker_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "lightning.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_walletunlocker_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_walletunlocker_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_walletunlocker_2eproto;
namespace lnrpc {
class ChangePasswordRequest;
struct ChangePasswordRequestDefaultTypeInternal;
extern ChangePasswordRequestDefaultTypeInternal _ChangePasswordRequest_default_instance_;
class ChangePasswordResponse;
struct ChangePasswordResponseDefaultTypeInternal;
extern ChangePasswordResponseDefaultTypeInternal _ChangePasswordResponse_default_instance_;
class GenSeedRequest;
struct GenSeedRequestDefaultTypeInternal;
extern GenSeedRequestDefaultTypeInternal _GenSeedRequest_default_instance_;
class GenSeedResponse;
struct GenSeedResponseDefaultTypeInternal;
extern GenSeedResponseDefaultTypeInternal _GenSeedResponse_default_instance_;
class InitWalletRequest;
struct InitWalletRequestDefaultTypeInternal;
extern InitWalletRequestDefaultTypeInternal _InitWalletRequest_default_instance_;
class InitWalletResponse;
struct InitWalletResponseDefaultTypeInternal;
extern InitWalletResponseDefaultTypeInternal _InitWalletResponse_default_instance_;
class UnlockWalletRequest;
struct UnlockWalletRequestDefaultTypeInternal;
extern UnlockWalletRequestDefaultTypeInternal _UnlockWalletRequest_default_instance_;
class UnlockWalletResponse;
struct UnlockWalletResponseDefaultTypeInternal;
extern UnlockWalletResponseDefaultTypeInternal _UnlockWalletResponse_default_instance_;
class WatchOnly;
struct WatchOnlyDefaultTypeInternal;
extern WatchOnlyDefaultTypeInternal _WatchOnly_default_instance_;
class WatchOnlyAccount;
struct WatchOnlyAccountDefaultTypeInternal;
extern WatchOnlyAccountDefaultTypeInternal _WatchOnlyAccount_default_instance_;
}  // namespace lnrpc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace lnrpc {

// ===================================================================


// -------------------------------------------------------------------

class WatchOnlyAccount final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lnrpc.WatchOnlyAccount) */ {
 public:
  inline WatchOnlyAccount() : WatchOnlyAccount(nullptr) {}
  ~WatchOnlyAccount() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WatchOnlyAccount(
      ::google::protobuf::internal::ConstantInitialized);

  inline WatchOnlyAccount(const WatchOnlyAccount& from) : WatchOnlyAccount(nullptr, from) {}
  inline WatchOnlyAccount(WatchOnlyAccount&& from) noexcept
      : WatchOnlyAccount(nullptr, std::move(from)) {}
  inline WatchOnlyAccount& operator=(const WatchOnlyAccount& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchOnlyAccount& operator=(WatchOnlyAccount&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchOnlyAccount& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchOnlyAccount* internal_default_instance() {
    return reinterpret_cast<const WatchOnlyAccount*>(
        &_WatchOnlyAccount_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(WatchOnlyAccount& a, WatchOnlyAccount& b) { a.Swap(&b); }
  inline void Swap(WatchOnlyAccount* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchOnlyAccount* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchOnlyAccount* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<WatchOnlyAccount>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WatchOnlyAccount& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WatchOnlyAccount& from) { WatchOnlyAccount::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WatchOnlyAccount* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "lnrpc.WatchOnlyAccount"; }

 protected:
  explicit WatchOnlyAccount(::google::protobuf::Arena* arena);
  WatchOnlyAccount(::google::protobuf::Arena* arena, const WatchOnlyAccount& from);
  WatchOnlyAccount(::google::protobuf::Arena* arena, WatchOnlyAccount&& from) noexcept
      : WatchOnlyAccount(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kXpubFieldNumber = 4,
    kPurposeFieldNumber = 1,
    kCoinTypeFieldNumber = 2,
    kAccountFieldNumber = 3,
  };
  // string xpub = 4;
  void clear_xpub() ;
  const std::string& xpub() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_xpub(Arg_&& arg, Args_... args);
  std::string* mutable_xpub();
  PROTOBUF_NODISCARD std::string* release_xpub();
  void set_allocated_xpub(std::string* value);

  private:
  const std::string& _internal_xpub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xpub(
      const std::string& value);
  std::string* _internal_mutable_xpub();

  public:
  // uint32 purpose = 1;
  void clear_purpose() ;
  ::uint32_t purpose() const;
  void set_purpose(::uint32_t value);

  private:
  ::uint32_t _internal_purpose() const;
  void _internal_set_purpose(::uint32_t value);

  public:
  // uint32 coin_type = 2;
  void clear_coin_type() ;
  ::uint32_t coin_type() const;
  void set_coin_type(::uint32_t value);

  private:
  ::uint32_t _internal_coin_type() const;
  void _internal_set_coin_type(::uint32_t value);

  public:
  // uint32 account = 3;
  void clear_account() ;
  ::uint32_t account() const;
  void set_account(::uint32_t value);

  private:
  ::uint32_t _internal_account() const;
  void _internal_set_account(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:lnrpc.WatchOnlyAccount)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      35, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_WatchOnlyAccount_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WatchOnlyAccount& from_msg);
    ::google::protobuf::internal::ArenaStringPtr xpub_;
    ::uint32_t purpose_;
    ::uint32_t coin_type_;
    ::uint32_t account_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_walletunlocker_2eproto;
};
// -------------------------------------------------------------------

class UnlockWalletResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:lnrpc.UnlockWalletResponse) */ {
 public:
  inline UnlockWalletResponse() : UnlockWalletResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnlockWalletResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline UnlockWalletResponse(const UnlockWalletResponse& from) : UnlockWalletResponse(nullptr, from) {}
  inline UnlockWalletResponse(UnlockWalletResponse&& from) noexcept
      : UnlockWalletResponse(nullptr, std::move(from)) {}
  inline UnlockWalletResponse& operator=(const UnlockWalletResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockWalletResponse& operator=(UnlockWalletResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockWalletResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockWalletResponse* internal_default_instance() {
    return reinterpret_cast<const UnlockWalletResponse*>(
        &_UnlockWalletResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(UnlockWalletResponse& a, UnlockWalletResponse& b) { a.Swap(&b); }
  inline void Swap(UnlockWalletResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockWalletResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockWalletResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<UnlockWalletResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UnlockWalletResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UnlockWalletResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "lnrpc.UnlockWalletResponse"; }

 protected:
  explicit UnlockWalletResponse(::google::protobuf::Arena* arena);
  UnlockWalletResponse(::google::protobuf::Arena* arena, const UnlockWalletResponse& from);
  UnlockWalletResponse(::google::protobuf::Arena* arena, UnlockWalletResponse&& from) noexcept
      : UnlockWalletResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:lnrpc.UnlockWalletResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UnlockWalletResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UnlockWalletResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_walletunlocker_2eproto;
};
// -------------------------------------------------------------------

class InitWalletResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lnrpc.InitWalletResponse) */ {
 public:
  inline InitWalletResponse() : InitWalletResponse(nullptr) {}
  ~InitWalletResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InitWalletResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline InitWalletResponse(const InitWalletResponse& from) : InitWalletResponse(nullptr, from) {}
  inline InitWalletResponse(InitWalletResponse&& from) noexcept
      : InitWalletResponse(nullptr, std::move(from)) {}
  inline InitWalletResponse& operator=(const InitWalletResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitWalletResponse& operator=(InitWalletResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitWalletResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitWalletResponse* internal_default_instance() {
    return reinterpret_cast<const InitWalletResponse*>(
        &_InitWalletResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(InitWalletResponse& a, InitWalletResponse& b) { a.Swap(&b); }
  inline void Swap(InitWalletResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitWalletResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitWalletResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<InitWalletResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InitWalletResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InitWalletResponse& from) { InitWalletResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InitWalletResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "lnrpc.InitWalletResponse"; }

 protected:
  explicit InitWalletResponse(::google::protobuf::Arena* arena);
  InitWalletResponse(::google::protobuf::Arena* arena, const InitWalletResponse& from);
  InitWalletResponse(::google::protobuf::Arena* arena, InitWalletResponse&& from) noexcept
      : InitWalletResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAdminMacaroonFieldNumber = 1,
  };
  // bytes admin_macaroon = 1;
  void clear_admin_macaroon() ;
  const std::string& admin_macaroon() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin_macaroon(Arg_&& arg, Args_... args);
  std::string* mutable_admin_macaroon();
  PROTOBUF_NODISCARD std::string* release_admin_macaroon();
  void set_allocated_admin_macaroon(std::string* value);

  private:
  const std::string& _internal_admin_macaroon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin_macaroon(
      const std::string& value);
  std::string* _internal_mutable_admin_macaroon();

  public:
  // @@protoc_insertion_point(class_scope:lnrpc.InitWalletResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InitWalletResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InitWalletResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr admin_macaroon_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_walletunlocker_2eproto;
};
// -------------------------------------------------------------------

class GenSeedResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lnrpc.GenSeedResponse) */ {
 public:
  inline GenSeedResponse() : GenSeedResponse(nullptr) {}
  ~GenSeedResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenSeedResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenSeedResponse(const GenSeedResponse& from) : GenSeedResponse(nullptr, from) {}
  inline GenSeedResponse(GenSeedResponse&& from) noexcept
      : GenSeedResponse(nullptr, std::move(from)) {}
  inline GenSeedResponse& operator=(const GenSeedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenSeedResponse& operator=(GenSeedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenSeedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenSeedResponse* internal_default_instance() {
    return reinterpret_cast<const GenSeedResponse*>(
        &_GenSeedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(GenSeedResponse& a, GenSeedResponse& b) { a.Swap(&b); }
  inline void Swap(GenSeedResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenSeedResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenSeedResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GenSeedResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenSeedResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenSeedResponse& from) { GenSeedResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenSeedResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "lnrpc.GenSeedResponse"; }

 protected:
  explicit GenSeedResponse(::google::protobuf::Arena* arena);
  GenSeedResponse(::google::protobuf::Arena* arena, const GenSeedResponse& from);
  GenSeedResponse(::google::protobuf::Arena* arena, GenSeedResponse&& from) noexcept
      : GenSeedResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCipherSeedMnemonicFieldNumber = 1,
    kEncipheredSeedFieldNumber = 2,
  };
  // repeated string cipher_seed_mnemonic = 1;
  int cipher_seed_mnemonic_size() const;
  private:
  int _internal_cipher_seed_mnemonic_size() const;

  public:
  void clear_cipher_seed_mnemonic() ;
  const std::string& cipher_seed_mnemonic(int index) const;
  std::string* mutable_cipher_seed_mnemonic(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cipher_seed_mnemonic(int index, Arg_&& value, Args_... args);
  std::string* add_cipher_seed_mnemonic();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_cipher_seed_mnemonic(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& cipher_seed_mnemonic() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_cipher_seed_mnemonic();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_cipher_seed_mnemonic() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_cipher_seed_mnemonic();

  public:
  // bytes enciphered_seed = 2;
  void clear_enciphered_seed() ;
  const std::string& enciphered_seed() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_enciphered_seed(Arg_&& arg, Args_... args);
  std::string* mutable_enciphered_seed();
  PROTOBUF_NODISCARD std::string* release_enciphered_seed();
  void set_allocated_enciphered_seed(std::string* value);

  private:
  const std::string& _internal_enciphered_seed() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_enciphered_seed(
      const std::string& value);
  std::string* _internal_mutable_enciphered_seed();

  public:
  // @@protoc_insertion_point(class_scope:lnrpc.GenSeedResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GenSeedResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenSeedResponse& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> cipher_seed_mnemonic_;
    ::google::protobuf::internal::ArenaStringPtr enciphered_seed_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_walletunlocker_2eproto;
};
// -------------------------------------------------------------------

class GenSeedRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lnrpc.GenSeedRequest) */ {
 public:
  inline GenSeedRequest() : GenSeedRequest(nullptr) {}
  ~GenSeedRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GenSeedRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline GenSeedRequest(const GenSeedRequest& from) : GenSeedRequest(nullptr, from) {}
  inline GenSeedRequest(GenSeedRequest&& from) noexcept
      : GenSeedRequest(nullptr, std::move(from)) {}
  inline GenSeedRequest& operator=(const GenSeedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GenSeedRequest& operator=(GenSeedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GenSeedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GenSeedRequest* internal_default_instance() {
    return reinterpret_cast<const GenSeedRequest*>(
        &_GenSeedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(GenSeedRequest& a, GenSeedRequest& b) { a.Swap(&b); }
  inline void Swap(GenSeedRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GenSeedRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GenSeedRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<GenSeedRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GenSeedRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GenSeedRequest& from) { GenSeedRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(GenSeedRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "lnrpc.GenSeedRequest"; }

 protected:
  explicit GenSeedRequest(::google::protobuf::Arena* arena);
  GenSeedRequest(::google::protobuf::Arena* arena, const GenSeedRequest& from);
  GenSeedRequest(::google::protobuf::Arena* arena, GenSeedRequest&& from) noexcept
      : GenSeedRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAezeedPassphraseFieldNumber = 1,
    kSeedEntropyFieldNumber = 2,
  };
  // bytes aezeed_passphrase = 1;
  void clear_aezeed_passphrase() ;
  const std::string& aezeed_passphrase() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_aezeed_passphrase(Arg_&& arg, Args_... args);
  std::string* mutable_aezeed_passphrase();
  PROTOBUF_NODISCARD std::string* release_aezeed_passphrase();
  void set_allocated_aezeed_passphrase(std::string* value);

  private:
  const std::string& _internal_aezeed_passphrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aezeed_passphrase(
      const std::string& value);
  std::string* _internal_mutable_aezeed_passphrase();

  public:
  // bytes seed_entropy = 2;
  void clear_seed_entropy() ;
  const std::string& seed_entropy() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_seed_entropy(Arg_&& arg, Args_... args);
  std::string* mutable_seed_entropy();
  PROTOBUF_NODISCARD std::string* release_seed_entropy();
  void set_allocated_seed_entropy(std::string* value);

  private:
  const std::string& _internal_seed_entropy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_seed_entropy(
      const std::string& value);
  std::string* _internal_mutable_seed_entropy();

  public:
  // @@protoc_insertion_point(class_scope:lnrpc.GenSeedRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_GenSeedRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GenSeedRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr aezeed_passphrase_;
    ::google::protobuf::internal::ArenaStringPtr seed_entropy_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_walletunlocker_2eproto;
};
// -------------------------------------------------------------------

class ChangePasswordResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lnrpc.ChangePasswordResponse) */ {
 public:
  inline ChangePasswordResponse() : ChangePasswordResponse(nullptr) {}
  ~ChangePasswordResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChangePasswordResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChangePasswordResponse(const ChangePasswordResponse& from) : ChangePasswordResponse(nullptr, from) {}
  inline ChangePasswordResponse(ChangePasswordResponse&& from) noexcept
      : ChangePasswordResponse(nullptr, std::move(from)) {}
  inline ChangePasswordResponse& operator=(const ChangePasswordResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePasswordResponse& operator=(ChangePasswordResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangePasswordResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangePasswordResponse* internal_default_instance() {
    return reinterpret_cast<const ChangePasswordResponse*>(
        &_ChangePasswordResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(ChangePasswordResponse& a, ChangePasswordResponse& b) { a.Swap(&b); }
  inline void Swap(ChangePasswordResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangePasswordResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangePasswordResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ChangePasswordResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangePasswordResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChangePasswordResponse& from) { ChangePasswordResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChangePasswordResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "lnrpc.ChangePasswordResponse"; }

 protected:
  explicit ChangePasswordResponse(::google::protobuf::Arena* arena);
  ChangePasswordResponse(::google::protobuf::Arena* arena, const ChangePasswordResponse& from);
  ChangePasswordResponse(::google::protobuf::Arena* arena, ChangePasswordResponse&& from) noexcept
      : ChangePasswordResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAdminMacaroonFieldNumber = 1,
  };
  // bytes admin_macaroon = 1;
  void clear_admin_macaroon() ;
  const std::string& admin_macaroon() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_admin_macaroon(Arg_&& arg, Args_... args);
  std::string* mutable_admin_macaroon();
  PROTOBUF_NODISCARD std::string* release_admin_macaroon();
  void set_allocated_admin_macaroon(std::string* value);

  private:
  const std::string& _internal_admin_macaroon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_admin_macaroon(
      const std::string& value);
  std::string* _internal_mutable_admin_macaroon();

  public:
  // @@protoc_insertion_point(class_scope:lnrpc.ChangePasswordResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ChangePasswordResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChangePasswordResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr admin_macaroon_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_walletunlocker_2eproto;
};
// -------------------------------------------------------------------

class ChangePasswordRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lnrpc.ChangePasswordRequest) */ {
 public:
  inline ChangePasswordRequest() : ChangePasswordRequest(nullptr) {}
  ~ChangePasswordRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR ChangePasswordRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline ChangePasswordRequest(const ChangePasswordRequest& from) : ChangePasswordRequest(nullptr, from) {}
  inline ChangePasswordRequest(ChangePasswordRequest&& from) noexcept
      : ChangePasswordRequest(nullptr, std::move(from)) {}
  inline ChangePasswordRequest& operator=(const ChangePasswordRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChangePasswordRequest& operator=(ChangePasswordRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChangePasswordRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChangePasswordRequest* internal_default_instance() {
    return reinterpret_cast<const ChangePasswordRequest*>(
        &_ChangePasswordRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(ChangePasswordRequest& a, ChangePasswordRequest& b) { a.Swap(&b); }
  inline void Swap(ChangePasswordRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChangePasswordRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChangePasswordRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<ChangePasswordRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ChangePasswordRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const ChangePasswordRequest& from) { ChangePasswordRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ChangePasswordRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "lnrpc.ChangePasswordRequest"; }

 protected:
  explicit ChangePasswordRequest(::google::protobuf::Arena* arena);
  ChangePasswordRequest(::google::protobuf::Arena* arena, const ChangePasswordRequest& from);
  ChangePasswordRequest(::google::protobuf::Arena* arena, ChangePasswordRequest&& from) noexcept
      : ChangePasswordRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCurrentPasswordFieldNumber = 1,
    kNewPasswordFieldNumber = 2,
    kStatelessInitFieldNumber = 3,
    kNewMacaroonRootKeyFieldNumber = 4,
  };
  // bytes current_password = 1;
  void clear_current_password() ;
  const std::string& current_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_current_password(Arg_&& arg, Args_... args);
  std::string* mutable_current_password();
  PROTOBUF_NODISCARD std::string* release_current_password();
  void set_allocated_current_password(std::string* value);

  private:
  const std::string& _internal_current_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_password(
      const std::string& value);
  std::string* _internal_mutable_current_password();

  public:
  // bytes new_password = 2;
  void clear_new_password() ;
  const std::string& new_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_new_password(Arg_&& arg, Args_... args);
  std::string* mutable_new_password();
  PROTOBUF_NODISCARD std::string* release_new_password();
  void set_allocated_new_password(std::string* value);

  private:
  const std::string& _internal_new_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_password(
      const std::string& value);
  std::string* _internal_mutable_new_password();

  public:
  // bool stateless_init = 3;
  void clear_stateless_init() ;
  bool stateless_init() const;
  void set_stateless_init(bool value);

  private:
  bool _internal_stateless_init() const;
  void _internal_set_stateless_init(bool value);

  public:
  // bool new_macaroon_root_key = 4;
  void clear_new_macaroon_root_key() ;
  bool new_macaroon_root_key() const;
  void set_new_macaroon_root_key(bool value);

  private:
  bool _internal_new_macaroon_root_key() const;
  void _internal_set_new_macaroon_root_key(bool value);

  public:
  // @@protoc_insertion_point(class_scope:lnrpc.ChangePasswordRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_ChangePasswordRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const ChangePasswordRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr current_password_;
    ::google::protobuf::internal::ArenaStringPtr new_password_;
    bool stateless_init_;
    bool new_macaroon_root_key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_walletunlocker_2eproto;
};
// -------------------------------------------------------------------

class WatchOnly final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lnrpc.WatchOnly) */ {
 public:
  inline WatchOnly() : WatchOnly(nullptr) {}
  ~WatchOnly() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR WatchOnly(
      ::google::protobuf::internal::ConstantInitialized);

  inline WatchOnly(const WatchOnly& from) : WatchOnly(nullptr, from) {}
  inline WatchOnly(WatchOnly&& from) noexcept
      : WatchOnly(nullptr, std::move(from)) {}
  inline WatchOnly& operator=(const WatchOnly& from) {
    CopyFrom(from);
    return *this;
  }
  inline WatchOnly& operator=(WatchOnly&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WatchOnly& default_instance() {
    return *internal_default_instance();
  }
  static inline const WatchOnly* internal_default_instance() {
    return reinterpret_cast<const WatchOnly*>(
        &_WatchOnly_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(WatchOnly& a, WatchOnly& b) { a.Swap(&b); }
  inline void Swap(WatchOnly* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WatchOnly* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WatchOnly* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<WatchOnly>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const WatchOnly& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const WatchOnly& from) { WatchOnly::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(WatchOnly* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "lnrpc.WatchOnly"; }

 protected:
  explicit WatchOnly(::google::protobuf::Arena* arena);
  WatchOnly(::google::protobuf::Arena* arena, const WatchOnly& from);
  WatchOnly(::google::protobuf::Arena* arena, WatchOnly&& from) noexcept
      : WatchOnly(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAccountsFieldNumber = 3,
    kMasterKeyFingerprintFieldNumber = 2,
    kMasterKeyBirthdayTimestampFieldNumber = 1,
  };
  // repeated .lnrpc.WatchOnlyAccount accounts = 3;
  int accounts_size() const;
  private:
  int _internal_accounts_size() const;

  public:
  void clear_accounts() ;
  ::lnrpc::WatchOnlyAccount* mutable_accounts(int index);
  ::google::protobuf::RepeatedPtrField<::lnrpc::WatchOnlyAccount>* mutable_accounts();

  private:
  const ::google::protobuf::RepeatedPtrField<::lnrpc::WatchOnlyAccount>& _internal_accounts() const;
  ::google::protobuf::RepeatedPtrField<::lnrpc::WatchOnlyAccount>* _internal_mutable_accounts();
  public:
  const ::lnrpc::WatchOnlyAccount& accounts(int index) const;
  ::lnrpc::WatchOnlyAccount* add_accounts();
  const ::google::protobuf::RepeatedPtrField<::lnrpc::WatchOnlyAccount>& accounts() const;
  // bytes master_key_fingerprint = 2;
  void clear_master_key_fingerprint() ;
  const std::string& master_key_fingerprint() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_master_key_fingerprint(Arg_&& arg, Args_... args);
  std::string* mutable_master_key_fingerprint();
  PROTOBUF_NODISCARD std::string* release_master_key_fingerprint();
  void set_allocated_master_key_fingerprint(std::string* value);

  private:
  const std::string& _internal_master_key_fingerprint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_master_key_fingerprint(
      const std::string& value);
  std::string* _internal_mutable_master_key_fingerprint();

  public:
  // uint64 master_key_birthday_timestamp = 1;
  void clear_master_key_birthday_timestamp() ;
  ::uint64_t master_key_birthday_timestamp() const;
  void set_master_key_birthday_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_master_key_birthday_timestamp() const;
  void _internal_set_master_key_birthday_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:lnrpc.WatchOnly)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_WatchOnly_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const WatchOnly& from_msg);
    ::google::protobuf::RepeatedPtrField< ::lnrpc::WatchOnlyAccount > accounts_;
    ::google::protobuf::internal::ArenaStringPtr master_key_fingerprint_;
    ::uint64_t master_key_birthday_timestamp_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_walletunlocker_2eproto;
};
// -------------------------------------------------------------------

class UnlockWalletRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lnrpc.UnlockWalletRequest) */ {
 public:
  inline UnlockWalletRequest() : UnlockWalletRequest(nullptr) {}
  ~UnlockWalletRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR UnlockWalletRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline UnlockWalletRequest(const UnlockWalletRequest& from) : UnlockWalletRequest(nullptr, from) {}
  inline UnlockWalletRequest(UnlockWalletRequest&& from) noexcept
      : UnlockWalletRequest(nullptr, std::move(from)) {}
  inline UnlockWalletRequest& operator=(const UnlockWalletRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UnlockWalletRequest& operator=(UnlockWalletRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UnlockWalletRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UnlockWalletRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockWalletRequest*>(
        &_UnlockWalletRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(UnlockWalletRequest& a, UnlockWalletRequest& b) { a.Swap(&b); }
  inline void Swap(UnlockWalletRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UnlockWalletRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UnlockWalletRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<UnlockWalletRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const UnlockWalletRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const UnlockWalletRequest& from) { UnlockWalletRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(UnlockWalletRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "lnrpc.UnlockWalletRequest"; }

 protected:
  explicit UnlockWalletRequest(::google::protobuf::Arena* arena);
  UnlockWalletRequest(::google::protobuf::Arena* arena, const UnlockWalletRequest& from);
  UnlockWalletRequest(::google::protobuf::Arena* arena, UnlockWalletRequest&& from) noexcept
      : UnlockWalletRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWalletPasswordFieldNumber = 1,
    kChannelBackupsFieldNumber = 3,
    kRecoveryWindowFieldNumber = 2,
    kStatelessInitFieldNumber = 4,
  };
  // bytes wallet_password = 1;
  void clear_wallet_password() ;
  const std::string& wallet_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wallet_password(Arg_&& arg, Args_... args);
  std::string* mutable_wallet_password();
  PROTOBUF_NODISCARD std::string* release_wallet_password();
  void set_allocated_wallet_password(std::string* value);

  private:
  const std::string& _internal_wallet_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wallet_password(
      const std::string& value);
  std::string* _internal_mutable_wallet_password();

  public:
  // .lnrpc.ChanBackupSnapshot channel_backups = 3;
  bool has_channel_backups() const;
  void clear_channel_backups() ;
  const ::lnrpc::ChanBackupSnapshot& channel_backups() const;
  PROTOBUF_NODISCARD ::lnrpc::ChanBackupSnapshot* release_channel_backups();
  ::lnrpc::ChanBackupSnapshot* mutable_channel_backups();
  void set_allocated_channel_backups(::lnrpc::ChanBackupSnapshot* value);
  void unsafe_arena_set_allocated_channel_backups(::lnrpc::ChanBackupSnapshot* value);
  ::lnrpc::ChanBackupSnapshot* unsafe_arena_release_channel_backups();

  private:
  const ::lnrpc::ChanBackupSnapshot& _internal_channel_backups() const;
  ::lnrpc::ChanBackupSnapshot* _internal_mutable_channel_backups();

  public:
  // int32 recovery_window = 2;
  void clear_recovery_window() ;
  ::int32_t recovery_window() const;
  void set_recovery_window(::int32_t value);

  private:
  ::int32_t _internal_recovery_window() const;
  void _internal_set_recovery_window(::int32_t value);

  public:
  // bool stateless_init = 4;
  void clear_stateless_init() ;
  bool stateless_init() const;
  void set_stateless_init(bool value);

  private:
  bool _internal_stateless_init() const;
  void _internal_set_stateless_init(bool value);

  public:
  // @@protoc_insertion_point(class_scope:lnrpc.UnlockWalletRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_UnlockWalletRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const UnlockWalletRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr wallet_password_;
    ::lnrpc::ChanBackupSnapshot* channel_backups_;
    ::int32_t recovery_window_;
    bool stateless_init_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_walletunlocker_2eproto;
};
// -------------------------------------------------------------------

class InitWalletRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:lnrpc.InitWalletRequest) */ {
 public:
  inline InitWalletRequest() : InitWalletRequest(nullptr) {}
  ~InitWalletRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InitWalletRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline InitWalletRequest(const InitWalletRequest& from) : InitWalletRequest(nullptr, from) {}
  inline InitWalletRequest(InitWalletRequest&& from) noexcept
      : InitWalletRequest(nullptr, std::move(from)) {}
  inline InitWalletRequest& operator=(const InitWalletRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InitWalletRequest& operator=(InitWalletRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InitWalletRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InitWalletRequest* internal_default_instance() {
    return reinterpret_cast<const InitWalletRequest*>(
        &_InitWalletRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(InitWalletRequest& a, InitWalletRequest& b) { a.Swap(&b); }
  inline void Swap(InitWalletRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InitWalletRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InitWalletRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<InitWalletRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InitWalletRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InitWalletRequest& from) { InitWalletRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InitWalletRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "lnrpc.InitWalletRequest"; }

 protected:
  explicit InitWalletRequest(::google::protobuf::Arena* arena);
  InitWalletRequest(::google::protobuf::Arena* arena, const InitWalletRequest& from);
  InitWalletRequest(::google::protobuf::Arena* arena, InitWalletRequest&& from) noexcept
      : InitWalletRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCipherSeedMnemonicFieldNumber = 2,
    kWalletPasswordFieldNumber = 1,
    kAezeedPassphraseFieldNumber = 3,
    kExtendedMasterKeyFieldNumber = 7,
    kMacaroonRootKeyFieldNumber = 10,
    kChannelBackupsFieldNumber = 5,
    kWatchOnlyFieldNumber = 9,
    kRecoveryWindowFieldNumber = 4,
    kStatelessInitFieldNumber = 6,
    kExtendedMasterKeyBirthdayTimestampFieldNumber = 8,
  };
  // repeated string cipher_seed_mnemonic = 2;
  int cipher_seed_mnemonic_size() const;
  private:
  int _internal_cipher_seed_mnemonic_size() const;

  public:
  void clear_cipher_seed_mnemonic() ;
  const std::string& cipher_seed_mnemonic(int index) const;
  std::string* mutable_cipher_seed_mnemonic(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_cipher_seed_mnemonic(int index, Arg_&& value, Args_... args);
  std::string* add_cipher_seed_mnemonic();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_cipher_seed_mnemonic(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& cipher_seed_mnemonic() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_cipher_seed_mnemonic();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_cipher_seed_mnemonic() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_cipher_seed_mnemonic();

  public:
  // bytes wallet_password = 1;
  void clear_wallet_password() ;
  const std::string& wallet_password() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_wallet_password(Arg_&& arg, Args_... args);
  std::string* mutable_wallet_password();
  PROTOBUF_NODISCARD std::string* release_wallet_password();
  void set_allocated_wallet_password(std::string* value);

  private:
  const std::string& _internal_wallet_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_wallet_password(
      const std::string& value);
  std::string* _internal_mutable_wallet_password();

  public:
  // bytes aezeed_passphrase = 3;
  void clear_aezeed_passphrase() ;
  const std::string& aezeed_passphrase() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_aezeed_passphrase(Arg_&& arg, Args_... args);
  std::string* mutable_aezeed_passphrase();
  PROTOBUF_NODISCARD std::string* release_aezeed_passphrase();
  void set_allocated_aezeed_passphrase(std::string* value);

  private:
  const std::string& _internal_aezeed_passphrase() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_aezeed_passphrase(
      const std::string& value);
  std::string* _internal_mutable_aezeed_passphrase();

  public:
  // string extended_master_key = 7;
  void clear_extended_master_key() ;
  const std::string& extended_master_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_extended_master_key(Arg_&& arg, Args_... args);
  std::string* mutable_extended_master_key();
  PROTOBUF_NODISCARD std::string* release_extended_master_key();
  void set_allocated_extended_master_key(std::string* value);

  private:
  const std::string& _internal_extended_master_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extended_master_key(
      const std::string& value);
  std::string* _internal_mutable_extended_master_key();

  public:
  // bytes macaroon_root_key = 10;
  void clear_macaroon_root_key() ;
  const std::string& macaroon_root_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_macaroon_root_key(Arg_&& arg, Args_... args);
  std::string* mutable_macaroon_root_key();
  PROTOBUF_NODISCARD std::string* release_macaroon_root_key();
  void set_allocated_macaroon_root_key(std::string* value);

  private:
  const std::string& _internal_macaroon_root_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_macaroon_root_key(
      const std::string& value);
  std::string* _internal_mutable_macaroon_root_key();

  public:
  // .lnrpc.ChanBackupSnapshot channel_backups = 5;
  bool has_channel_backups() const;
  void clear_channel_backups() ;
  const ::lnrpc::ChanBackupSnapshot& channel_backups() const;
  PROTOBUF_NODISCARD ::lnrpc::ChanBackupSnapshot* release_channel_backups();
  ::lnrpc::ChanBackupSnapshot* mutable_channel_backups();
  void set_allocated_channel_backups(::lnrpc::ChanBackupSnapshot* value);
  void unsafe_arena_set_allocated_channel_backups(::lnrpc::ChanBackupSnapshot* value);
  ::lnrpc::ChanBackupSnapshot* unsafe_arena_release_channel_backups();

  private:
  const ::lnrpc::ChanBackupSnapshot& _internal_channel_backups() const;
  ::lnrpc::ChanBackupSnapshot* _internal_mutable_channel_backups();

  public:
  // .lnrpc.WatchOnly watch_only = 9;
  bool has_watch_only() const;
  void clear_watch_only() ;
  const ::lnrpc::WatchOnly& watch_only() const;
  PROTOBUF_NODISCARD ::lnrpc::WatchOnly* release_watch_only();
  ::lnrpc::WatchOnly* mutable_watch_only();
  void set_allocated_watch_only(::lnrpc::WatchOnly* value);
  void unsafe_arena_set_allocated_watch_only(::lnrpc::WatchOnly* value);
  ::lnrpc::WatchOnly* unsafe_arena_release_watch_only();

  private:
  const ::lnrpc::WatchOnly& _internal_watch_only() const;
  ::lnrpc::WatchOnly* _internal_mutable_watch_only();

  public:
  // int32 recovery_window = 4;
  void clear_recovery_window() ;
  ::int32_t recovery_window() const;
  void set_recovery_window(::int32_t value);

  private:
  ::int32_t _internal_recovery_window() const;
  void _internal_set_recovery_window(::int32_t value);

  public:
  // bool stateless_init = 6;
  void clear_stateless_init() ;
  bool stateless_init() const;
  void set_stateless_init(bool value);

  private:
  bool _internal_stateless_init() const;
  void _internal_set_stateless_init(bool value);

  public:
  // uint64 extended_master_key_birthday_timestamp = 8;
  void clear_extended_master_key_birthday_timestamp() ;
  ::uint64_t extended_master_key_birthday_timestamp() const;
  void set_extended_master_key_birthday_timestamp(::uint64_t value);

  private:
  ::uint64_t _internal_extended_master_key_birthday_timestamp() const;
  void _internal_set_extended_master_key_birthday_timestamp(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:lnrpc.InitWalletRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 2,
      79, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InitWalletRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InitWalletRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> cipher_seed_mnemonic_;
    ::google::protobuf::internal::ArenaStringPtr wallet_password_;
    ::google::protobuf::internal::ArenaStringPtr aezeed_passphrase_;
    ::google::protobuf::internal::ArenaStringPtr extended_master_key_;
    ::google::protobuf::internal::ArenaStringPtr macaroon_root_key_;
    ::lnrpc::ChanBackupSnapshot* channel_backups_;
    ::lnrpc::WatchOnly* watch_only_;
    ::int32_t recovery_window_;
    bool stateless_init_;
    ::uint64_t extended_master_key_birthday_timestamp_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_walletunlocker_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// GenSeedRequest

// bytes aezeed_passphrase = 1;
inline void GenSeedRequest::clear_aezeed_passphrase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aezeed_passphrase_.ClearToEmpty();
}
inline const std::string& GenSeedRequest::aezeed_passphrase() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.GenSeedRequest.aezeed_passphrase)
  return _internal_aezeed_passphrase();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenSeedRequest::set_aezeed_passphrase(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aezeed_passphrase_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.GenSeedRequest.aezeed_passphrase)
}
inline std::string* GenSeedRequest::mutable_aezeed_passphrase() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_aezeed_passphrase();
  // @@protoc_insertion_point(field_mutable:lnrpc.GenSeedRequest.aezeed_passphrase)
  return _s;
}
inline const std::string& GenSeedRequest::_internal_aezeed_passphrase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aezeed_passphrase_.Get();
}
inline void GenSeedRequest::_internal_set_aezeed_passphrase(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aezeed_passphrase_.Set(value, GetArena());
}
inline std::string* GenSeedRequest::_internal_mutable_aezeed_passphrase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.aezeed_passphrase_.Mutable( GetArena());
}
inline std::string* GenSeedRequest::release_aezeed_passphrase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.GenSeedRequest.aezeed_passphrase)
  return _impl_.aezeed_passphrase_.Release();
}
inline void GenSeedRequest::set_allocated_aezeed_passphrase(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aezeed_passphrase_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.aezeed_passphrase_.IsDefault()) {
          _impl_.aezeed_passphrase_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.GenSeedRequest.aezeed_passphrase)
}

// bytes seed_entropy = 2;
inline void GenSeedRequest::clear_seed_entropy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seed_entropy_.ClearToEmpty();
}
inline const std::string& GenSeedRequest::seed_entropy() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.GenSeedRequest.seed_entropy)
  return _internal_seed_entropy();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenSeedRequest::set_seed_entropy(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seed_entropy_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.GenSeedRequest.seed_entropy)
}
inline std::string* GenSeedRequest::mutable_seed_entropy() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_seed_entropy();
  // @@protoc_insertion_point(field_mutable:lnrpc.GenSeedRequest.seed_entropy)
  return _s;
}
inline const std::string& GenSeedRequest::_internal_seed_entropy() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.seed_entropy_.Get();
}
inline void GenSeedRequest::_internal_set_seed_entropy(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seed_entropy_.Set(value, GetArena());
}
inline std::string* GenSeedRequest::_internal_mutable_seed_entropy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.seed_entropy_.Mutable( GetArena());
}
inline std::string* GenSeedRequest::release_seed_entropy() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.GenSeedRequest.seed_entropy)
  return _impl_.seed_entropy_.Release();
}
inline void GenSeedRequest::set_allocated_seed_entropy(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seed_entropy_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.seed_entropy_.IsDefault()) {
          _impl_.seed_entropy_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.GenSeedRequest.seed_entropy)
}

// -------------------------------------------------------------------

// GenSeedResponse

// repeated string cipher_seed_mnemonic = 1;
inline int GenSeedResponse::_internal_cipher_seed_mnemonic_size() const {
  return _internal_cipher_seed_mnemonic().size();
}
inline int GenSeedResponse::cipher_seed_mnemonic_size() const {
  return _internal_cipher_seed_mnemonic_size();
}
inline void GenSeedResponse::clear_cipher_seed_mnemonic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cipher_seed_mnemonic_.Clear();
}
inline std::string* GenSeedResponse::add_cipher_seed_mnemonic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_cipher_seed_mnemonic()->Add();
  // @@protoc_insertion_point(field_add_mutable:lnrpc.GenSeedResponse.cipher_seed_mnemonic)
  return _s;
}
inline const std::string& GenSeedResponse::cipher_seed_mnemonic(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.GenSeedResponse.cipher_seed_mnemonic)
  return _internal_cipher_seed_mnemonic().Get(index);
}
inline std::string* GenSeedResponse::mutable_cipher_seed_mnemonic(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lnrpc.GenSeedResponse.cipher_seed_mnemonic)
  return _internal_mutable_cipher_seed_mnemonic()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GenSeedResponse::set_cipher_seed_mnemonic(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_cipher_seed_mnemonic()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:lnrpc.GenSeedResponse.cipher_seed_mnemonic)
}
template <typename Arg_, typename... Args_>
inline void GenSeedResponse::add_cipher_seed_mnemonic(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_cipher_seed_mnemonic(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:lnrpc.GenSeedResponse.cipher_seed_mnemonic)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GenSeedResponse::cipher_seed_mnemonic() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lnrpc.GenSeedResponse.cipher_seed_mnemonic)
  return _internal_cipher_seed_mnemonic();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GenSeedResponse::mutable_cipher_seed_mnemonic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lnrpc.GenSeedResponse.cipher_seed_mnemonic)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cipher_seed_mnemonic();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GenSeedResponse::_internal_cipher_seed_mnemonic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cipher_seed_mnemonic_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GenSeedResponse::_internal_mutable_cipher_seed_mnemonic() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cipher_seed_mnemonic_;
}

// bytes enciphered_seed = 2;
inline void GenSeedResponse::clear_enciphered_seed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enciphered_seed_.ClearToEmpty();
}
inline const std::string& GenSeedResponse::enciphered_seed() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.GenSeedResponse.enciphered_seed)
  return _internal_enciphered_seed();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GenSeedResponse::set_enciphered_seed(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enciphered_seed_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.GenSeedResponse.enciphered_seed)
}
inline std::string* GenSeedResponse::mutable_enciphered_seed() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_enciphered_seed();
  // @@protoc_insertion_point(field_mutable:lnrpc.GenSeedResponse.enciphered_seed)
  return _s;
}
inline const std::string& GenSeedResponse::_internal_enciphered_seed() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.enciphered_seed_.Get();
}
inline void GenSeedResponse::_internal_set_enciphered_seed(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enciphered_seed_.Set(value, GetArena());
}
inline std::string* GenSeedResponse::_internal_mutable_enciphered_seed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.enciphered_seed_.Mutable( GetArena());
}
inline std::string* GenSeedResponse::release_enciphered_seed() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.GenSeedResponse.enciphered_seed)
  return _impl_.enciphered_seed_.Release();
}
inline void GenSeedResponse::set_allocated_enciphered_seed(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.enciphered_seed_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.enciphered_seed_.IsDefault()) {
          _impl_.enciphered_seed_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.GenSeedResponse.enciphered_seed)
}

// -------------------------------------------------------------------

// InitWalletRequest

// bytes wallet_password = 1;
inline void InitWalletRequest::clear_wallet_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wallet_password_.ClearToEmpty();
}
inline const std::string& InitWalletRequest::wallet_password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletRequest.wallet_password)
  return _internal_wallet_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InitWalletRequest::set_wallet_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wallet_password_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.InitWalletRequest.wallet_password)
}
inline std::string* InitWalletRequest::mutable_wallet_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_wallet_password();
  // @@protoc_insertion_point(field_mutable:lnrpc.InitWalletRequest.wallet_password)
  return _s;
}
inline const std::string& InitWalletRequest::_internal_wallet_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wallet_password_.Get();
}
inline void InitWalletRequest::_internal_set_wallet_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wallet_password_.Set(value, GetArena());
}
inline std::string* InitWalletRequest::_internal_mutable_wallet_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.wallet_password_.Mutable( GetArena());
}
inline std::string* InitWalletRequest::release_wallet_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.InitWalletRequest.wallet_password)
  return _impl_.wallet_password_.Release();
}
inline void InitWalletRequest::set_allocated_wallet_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wallet_password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.wallet_password_.IsDefault()) {
          _impl_.wallet_password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.InitWalletRequest.wallet_password)
}

// repeated string cipher_seed_mnemonic = 2;
inline int InitWalletRequest::_internal_cipher_seed_mnemonic_size() const {
  return _internal_cipher_seed_mnemonic().size();
}
inline int InitWalletRequest::cipher_seed_mnemonic_size() const {
  return _internal_cipher_seed_mnemonic_size();
}
inline void InitWalletRequest::clear_cipher_seed_mnemonic() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cipher_seed_mnemonic_.Clear();
}
inline std::string* InitWalletRequest::add_cipher_seed_mnemonic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_cipher_seed_mnemonic()->Add();
  // @@protoc_insertion_point(field_add_mutable:lnrpc.InitWalletRequest.cipher_seed_mnemonic)
  return _s;
}
inline const std::string& InitWalletRequest::cipher_seed_mnemonic(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletRequest.cipher_seed_mnemonic)
  return _internal_cipher_seed_mnemonic().Get(index);
}
inline std::string* InitWalletRequest::mutable_cipher_seed_mnemonic(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lnrpc.InitWalletRequest.cipher_seed_mnemonic)
  return _internal_mutable_cipher_seed_mnemonic()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void InitWalletRequest::set_cipher_seed_mnemonic(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_cipher_seed_mnemonic()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:lnrpc.InitWalletRequest.cipher_seed_mnemonic)
}
template <typename Arg_, typename... Args_>
inline void InitWalletRequest::add_cipher_seed_mnemonic(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_cipher_seed_mnemonic(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:lnrpc.InitWalletRequest.cipher_seed_mnemonic)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
InitWalletRequest::cipher_seed_mnemonic() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lnrpc.InitWalletRequest.cipher_seed_mnemonic)
  return _internal_cipher_seed_mnemonic();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
InitWalletRequest::mutable_cipher_seed_mnemonic() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lnrpc.InitWalletRequest.cipher_seed_mnemonic)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_cipher_seed_mnemonic();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
InitWalletRequest::_internal_cipher_seed_mnemonic() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cipher_seed_mnemonic_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
InitWalletRequest::_internal_mutable_cipher_seed_mnemonic() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.cipher_seed_mnemonic_;
}

// bytes aezeed_passphrase = 3;
inline void InitWalletRequest::clear_aezeed_passphrase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aezeed_passphrase_.ClearToEmpty();
}
inline const std::string& InitWalletRequest::aezeed_passphrase() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletRequest.aezeed_passphrase)
  return _internal_aezeed_passphrase();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InitWalletRequest::set_aezeed_passphrase(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aezeed_passphrase_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.InitWalletRequest.aezeed_passphrase)
}
inline std::string* InitWalletRequest::mutable_aezeed_passphrase() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_aezeed_passphrase();
  // @@protoc_insertion_point(field_mutable:lnrpc.InitWalletRequest.aezeed_passphrase)
  return _s;
}
inline const std::string& InitWalletRequest::_internal_aezeed_passphrase() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aezeed_passphrase_.Get();
}
inline void InitWalletRequest::_internal_set_aezeed_passphrase(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aezeed_passphrase_.Set(value, GetArena());
}
inline std::string* InitWalletRequest::_internal_mutable_aezeed_passphrase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.aezeed_passphrase_.Mutable( GetArena());
}
inline std::string* InitWalletRequest::release_aezeed_passphrase() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.InitWalletRequest.aezeed_passphrase)
  return _impl_.aezeed_passphrase_.Release();
}
inline void InitWalletRequest::set_allocated_aezeed_passphrase(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aezeed_passphrase_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.aezeed_passphrase_.IsDefault()) {
          _impl_.aezeed_passphrase_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.InitWalletRequest.aezeed_passphrase)
}

// int32 recovery_window = 4;
inline void InitWalletRequest::clear_recovery_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_window_ = 0;
}
inline ::int32_t InitWalletRequest::recovery_window() const {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletRequest.recovery_window)
  return _internal_recovery_window();
}
inline void InitWalletRequest::set_recovery_window(::int32_t value) {
  _internal_set_recovery_window(value);
  // @@protoc_insertion_point(field_set:lnrpc.InitWalletRequest.recovery_window)
}
inline ::int32_t InitWalletRequest::_internal_recovery_window() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recovery_window_;
}
inline void InitWalletRequest::_internal_set_recovery_window(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_window_ = value;
}

// .lnrpc.ChanBackupSnapshot channel_backups = 5;
inline bool InitWalletRequest::has_channel_backups() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.channel_backups_ != nullptr);
  return value;
}
inline const ::lnrpc::ChanBackupSnapshot& InitWalletRequest::_internal_channel_backups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::lnrpc::ChanBackupSnapshot* p = _impl_.channel_backups_;
  return p != nullptr ? *p : reinterpret_cast<const ::lnrpc::ChanBackupSnapshot&>(::lnrpc::_ChanBackupSnapshot_default_instance_);
}
inline const ::lnrpc::ChanBackupSnapshot& InitWalletRequest::channel_backups() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletRequest.channel_backups)
  return _internal_channel_backups();
}
inline void InitWalletRequest::unsafe_arena_set_allocated_channel_backups(::lnrpc::ChanBackupSnapshot* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.channel_backups_);
  }
  _impl_.channel_backups_ = reinterpret_cast<::lnrpc::ChanBackupSnapshot*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lnrpc.InitWalletRequest.channel_backups)
}
inline ::lnrpc::ChanBackupSnapshot* InitWalletRequest::release_channel_backups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lnrpc::ChanBackupSnapshot* released = _impl_.channel_backups_;
  _impl_.channel_backups_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::lnrpc::ChanBackupSnapshot* InitWalletRequest::unsafe_arena_release_channel_backups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.InitWalletRequest.channel_backups)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lnrpc::ChanBackupSnapshot* temp = _impl_.channel_backups_;
  _impl_.channel_backups_ = nullptr;
  return temp;
}
inline ::lnrpc::ChanBackupSnapshot* InitWalletRequest::_internal_mutable_channel_backups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.channel_backups_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::lnrpc::ChanBackupSnapshot>(GetArena());
    _impl_.channel_backups_ = reinterpret_cast<::lnrpc::ChanBackupSnapshot*>(p);
  }
  return _impl_.channel_backups_;
}
inline ::lnrpc::ChanBackupSnapshot* InitWalletRequest::mutable_channel_backups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::lnrpc::ChanBackupSnapshot* _msg = _internal_mutable_channel_backups();
  // @@protoc_insertion_point(field_mutable:lnrpc.InitWalletRequest.channel_backups)
  return _msg;
}
inline void InitWalletRequest::set_allocated_channel_backups(::lnrpc::ChanBackupSnapshot* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.channel_backups_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.channel_backups_ = reinterpret_cast<::lnrpc::ChanBackupSnapshot*>(value);
  // @@protoc_insertion_point(field_set_allocated:lnrpc.InitWalletRequest.channel_backups)
}

// bool stateless_init = 6;
inline void InitWalletRequest::clear_stateless_init() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stateless_init_ = false;
}
inline bool InitWalletRequest::stateless_init() const {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletRequest.stateless_init)
  return _internal_stateless_init();
}
inline void InitWalletRequest::set_stateless_init(bool value) {
  _internal_set_stateless_init(value);
  // @@protoc_insertion_point(field_set:lnrpc.InitWalletRequest.stateless_init)
}
inline bool InitWalletRequest::_internal_stateless_init() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stateless_init_;
}
inline void InitWalletRequest::_internal_set_stateless_init(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stateless_init_ = value;
}

// string extended_master_key = 7;
inline void InitWalletRequest::clear_extended_master_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extended_master_key_.ClearToEmpty();
}
inline const std::string& InitWalletRequest::extended_master_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletRequest.extended_master_key)
  return _internal_extended_master_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InitWalletRequest::set_extended_master_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extended_master_key_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.InitWalletRequest.extended_master_key)
}
inline std::string* InitWalletRequest::mutable_extended_master_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_extended_master_key();
  // @@protoc_insertion_point(field_mutable:lnrpc.InitWalletRequest.extended_master_key)
  return _s;
}
inline const std::string& InitWalletRequest::_internal_extended_master_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extended_master_key_.Get();
}
inline void InitWalletRequest::_internal_set_extended_master_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extended_master_key_.Set(value, GetArena());
}
inline std::string* InitWalletRequest::_internal_mutable_extended_master_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.extended_master_key_.Mutable( GetArena());
}
inline std::string* InitWalletRequest::release_extended_master_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.InitWalletRequest.extended_master_key)
  return _impl_.extended_master_key_.Release();
}
inline void InitWalletRequest::set_allocated_extended_master_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extended_master_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.extended_master_key_.IsDefault()) {
          _impl_.extended_master_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.InitWalletRequest.extended_master_key)
}

// uint64 extended_master_key_birthday_timestamp = 8;
inline void InitWalletRequest::clear_extended_master_key_birthday_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extended_master_key_birthday_timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t InitWalletRequest::extended_master_key_birthday_timestamp() const {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletRequest.extended_master_key_birthday_timestamp)
  return _internal_extended_master_key_birthday_timestamp();
}
inline void InitWalletRequest::set_extended_master_key_birthday_timestamp(::uint64_t value) {
  _internal_set_extended_master_key_birthday_timestamp(value);
  // @@protoc_insertion_point(field_set:lnrpc.InitWalletRequest.extended_master_key_birthday_timestamp)
}
inline ::uint64_t InitWalletRequest::_internal_extended_master_key_birthday_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.extended_master_key_birthday_timestamp_;
}
inline void InitWalletRequest::_internal_set_extended_master_key_birthday_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.extended_master_key_birthday_timestamp_ = value;
}

// .lnrpc.WatchOnly watch_only = 9;
inline bool InitWalletRequest::has_watch_only() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.watch_only_ != nullptr);
  return value;
}
inline void InitWalletRequest::clear_watch_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.watch_only_ != nullptr) _impl_.watch_only_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::lnrpc::WatchOnly& InitWalletRequest::_internal_watch_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::lnrpc::WatchOnly* p = _impl_.watch_only_;
  return p != nullptr ? *p : reinterpret_cast<const ::lnrpc::WatchOnly&>(::lnrpc::_WatchOnly_default_instance_);
}
inline const ::lnrpc::WatchOnly& InitWalletRequest::watch_only() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletRequest.watch_only)
  return _internal_watch_only();
}
inline void InitWalletRequest::unsafe_arena_set_allocated_watch_only(::lnrpc::WatchOnly* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.watch_only_);
  }
  _impl_.watch_only_ = reinterpret_cast<::lnrpc::WatchOnly*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lnrpc.InitWalletRequest.watch_only)
}
inline ::lnrpc::WatchOnly* InitWalletRequest::release_watch_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::lnrpc::WatchOnly* released = _impl_.watch_only_;
  _impl_.watch_only_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::lnrpc::WatchOnly* InitWalletRequest::unsafe_arena_release_watch_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.InitWalletRequest.watch_only)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::lnrpc::WatchOnly* temp = _impl_.watch_only_;
  _impl_.watch_only_ = nullptr;
  return temp;
}
inline ::lnrpc::WatchOnly* InitWalletRequest::_internal_mutable_watch_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.watch_only_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::lnrpc::WatchOnly>(GetArena());
    _impl_.watch_only_ = reinterpret_cast<::lnrpc::WatchOnly*>(p);
  }
  return _impl_.watch_only_;
}
inline ::lnrpc::WatchOnly* InitWalletRequest::mutable_watch_only() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::lnrpc::WatchOnly* _msg = _internal_mutable_watch_only();
  // @@protoc_insertion_point(field_mutable:lnrpc.InitWalletRequest.watch_only)
  return _msg;
}
inline void InitWalletRequest::set_allocated_watch_only(::lnrpc::WatchOnly* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.watch_only_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.watch_only_ = reinterpret_cast<::lnrpc::WatchOnly*>(value);
  // @@protoc_insertion_point(field_set_allocated:lnrpc.InitWalletRequest.watch_only)
}

// bytes macaroon_root_key = 10;
inline void InitWalletRequest::clear_macaroon_root_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.macaroon_root_key_.ClearToEmpty();
}
inline const std::string& InitWalletRequest::macaroon_root_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletRequest.macaroon_root_key)
  return _internal_macaroon_root_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InitWalletRequest::set_macaroon_root_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.macaroon_root_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.InitWalletRequest.macaroon_root_key)
}
inline std::string* InitWalletRequest::mutable_macaroon_root_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_macaroon_root_key();
  // @@protoc_insertion_point(field_mutable:lnrpc.InitWalletRequest.macaroon_root_key)
  return _s;
}
inline const std::string& InitWalletRequest::_internal_macaroon_root_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.macaroon_root_key_.Get();
}
inline void InitWalletRequest::_internal_set_macaroon_root_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.macaroon_root_key_.Set(value, GetArena());
}
inline std::string* InitWalletRequest::_internal_mutable_macaroon_root_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.macaroon_root_key_.Mutable( GetArena());
}
inline std::string* InitWalletRequest::release_macaroon_root_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.InitWalletRequest.macaroon_root_key)
  return _impl_.macaroon_root_key_.Release();
}
inline void InitWalletRequest::set_allocated_macaroon_root_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.macaroon_root_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.macaroon_root_key_.IsDefault()) {
          _impl_.macaroon_root_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.InitWalletRequest.macaroon_root_key)
}

// -------------------------------------------------------------------

// InitWalletResponse

// bytes admin_macaroon = 1;
inline void InitWalletResponse::clear_admin_macaroon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_macaroon_.ClearToEmpty();
}
inline const std::string& InitWalletResponse::admin_macaroon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.InitWalletResponse.admin_macaroon)
  return _internal_admin_macaroon();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InitWalletResponse::set_admin_macaroon(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_macaroon_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.InitWalletResponse.admin_macaroon)
}
inline std::string* InitWalletResponse::mutable_admin_macaroon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_admin_macaroon();
  // @@protoc_insertion_point(field_mutable:lnrpc.InitWalletResponse.admin_macaroon)
  return _s;
}
inline const std::string& InitWalletResponse::_internal_admin_macaroon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.admin_macaroon_.Get();
}
inline void InitWalletResponse::_internal_set_admin_macaroon(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_macaroon_.Set(value, GetArena());
}
inline std::string* InitWalletResponse::_internal_mutable_admin_macaroon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.admin_macaroon_.Mutable( GetArena());
}
inline std::string* InitWalletResponse::release_admin_macaroon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.InitWalletResponse.admin_macaroon)
  return _impl_.admin_macaroon_.Release();
}
inline void InitWalletResponse::set_allocated_admin_macaroon(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_macaroon_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_macaroon_.IsDefault()) {
          _impl_.admin_macaroon_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.InitWalletResponse.admin_macaroon)
}

// -------------------------------------------------------------------

// WatchOnly

// uint64 master_key_birthday_timestamp = 1;
inline void WatchOnly::clear_master_key_birthday_timestamp() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.master_key_birthday_timestamp_ = ::uint64_t{0u};
}
inline ::uint64_t WatchOnly::master_key_birthday_timestamp() const {
  // @@protoc_insertion_point(field_get:lnrpc.WatchOnly.master_key_birthday_timestamp)
  return _internal_master_key_birthday_timestamp();
}
inline void WatchOnly::set_master_key_birthday_timestamp(::uint64_t value) {
  _internal_set_master_key_birthday_timestamp(value);
  // @@protoc_insertion_point(field_set:lnrpc.WatchOnly.master_key_birthday_timestamp)
}
inline ::uint64_t WatchOnly::_internal_master_key_birthday_timestamp() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.master_key_birthday_timestamp_;
}
inline void WatchOnly::_internal_set_master_key_birthday_timestamp(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.master_key_birthday_timestamp_ = value;
}

// bytes master_key_fingerprint = 2;
inline void WatchOnly::clear_master_key_fingerprint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.master_key_fingerprint_.ClearToEmpty();
}
inline const std::string& WatchOnly::master_key_fingerprint() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.WatchOnly.master_key_fingerprint)
  return _internal_master_key_fingerprint();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WatchOnly::set_master_key_fingerprint(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.master_key_fingerprint_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.WatchOnly.master_key_fingerprint)
}
inline std::string* WatchOnly::mutable_master_key_fingerprint() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_master_key_fingerprint();
  // @@protoc_insertion_point(field_mutable:lnrpc.WatchOnly.master_key_fingerprint)
  return _s;
}
inline const std::string& WatchOnly::_internal_master_key_fingerprint() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.master_key_fingerprint_.Get();
}
inline void WatchOnly::_internal_set_master_key_fingerprint(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.master_key_fingerprint_.Set(value, GetArena());
}
inline std::string* WatchOnly::_internal_mutable_master_key_fingerprint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.master_key_fingerprint_.Mutable( GetArena());
}
inline std::string* WatchOnly::release_master_key_fingerprint() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.WatchOnly.master_key_fingerprint)
  return _impl_.master_key_fingerprint_.Release();
}
inline void WatchOnly::set_allocated_master_key_fingerprint(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.master_key_fingerprint_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.master_key_fingerprint_.IsDefault()) {
          _impl_.master_key_fingerprint_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.WatchOnly.master_key_fingerprint)
}

// repeated .lnrpc.WatchOnlyAccount accounts = 3;
inline int WatchOnly::_internal_accounts_size() const {
  return _internal_accounts().size();
}
inline int WatchOnly::accounts_size() const {
  return _internal_accounts_size();
}
inline void WatchOnly::clear_accounts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.accounts_.Clear();
}
inline ::lnrpc::WatchOnlyAccount* WatchOnly::mutable_accounts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:lnrpc.WatchOnly.accounts)
  return _internal_mutable_accounts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::lnrpc::WatchOnlyAccount>* WatchOnly::mutable_accounts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:lnrpc.WatchOnly.accounts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_accounts();
}
inline const ::lnrpc::WatchOnlyAccount& WatchOnly::accounts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.WatchOnly.accounts)
  return _internal_accounts().Get(index);
}
inline ::lnrpc::WatchOnlyAccount* WatchOnly::add_accounts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::lnrpc::WatchOnlyAccount* _add = _internal_mutable_accounts()->Add();
  // @@protoc_insertion_point(field_add:lnrpc.WatchOnly.accounts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::lnrpc::WatchOnlyAccount>& WatchOnly::accounts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:lnrpc.WatchOnly.accounts)
  return _internal_accounts();
}
inline const ::google::protobuf::RepeatedPtrField<::lnrpc::WatchOnlyAccount>&
WatchOnly::_internal_accounts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.accounts_;
}
inline ::google::protobuf::RepeatedPtrField<::lnrpc::WatchOnlyAccount>*
WatchOnly::_internal_mutable_accounts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.accounts_;
}

// -------------------------------------------------------------------

// WatchOnlyAccount

// uint32 purpose = 1;
inline void WatchOnlyAccount::clear_purpose() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.purpose_ = 0u;
}
inline ::uint32_t WatchOnlyAccount::purpose() const {
  // @@protoc_insertion_point(field_get:lnrpc.WatchOnlyAccount.purpose)
  return _internal_purpose();
}
inline void WatchOnlyAccount::set_purpose(::uint32_t value) {
  _internal_set_purpose(value);
  // @@protoc_insertion_point(field_set:lnrpc.WatchOnlyAccount.purpose)
}
inline ::uint32_t WatchOnlyAccount::_internal_purpose() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.purpose_;
}
inline void WatchOnlyAccount::_internal_set_purpose(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.purpose_ = value;
}

// uint32 coin_type = 2;
inline void WatchOnlyAccount::clear_coin_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coin_type_ = 0u;
}
inline ::uint32_t WatchOnlyAccount::coin_type() const {
  // @@protoc_insertion_point(field_get:lnrpc.WatchOnlyAccount.coin_type)
  return _internal_coin_type();
}
inline void WatchOnlyAccount::set_coin_type(::uint32_t value) {
  _internal_set_coin_type(value);
  // @@protoc_insertion_point(field_set:lnrpc.WatchOnlyAccount.coin_type)
}
inline ::uint32_t WatchOnlyAccount::_internal_coin_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.coin_type_;
}
inline void WatchOnlyAccount::_internal_set_coin_type(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.coin_type_ = value;
}

// uint32 account = 3;
inline void WatchOnlyAccount::clear_account() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_ = 0u;
}
inline ::uint32_t WatchOnlyAccount::account() const {
  // @@protoc_insertion_point(field_get:lnrpc.WatchOnlyAccount.account)
  return _internal_account();
}
inline void WatchOnlyAccount::set_account(::uint32_t value) {
  _internal_set_account(value);
  // @@protoc_insertion_point(field_set:lnrpc.WatchOnlyAccount.account)
}
inline ::uint32_t WatchOnlyAccount::_internal_account() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.account_;
}
inline void WatchOnlyAccount::_internal_set_account(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.account_ = value;
}

// string xpub = 4;
inline void WatchOnlyAccount::clear_xpub() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xpub_.ClearToEmpty();
}
inline const std::string& WatchOnlyAccount::xpub() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.WatchOnlyAccount.xpub)
  return _internal_xpub();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void WatchOnlyAccount::set_xpub(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xpub_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.WatchOnlyAccount.xpub)
}
inline std::string* WatchOnlyAccount::mutable_xpub() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_xpub();
  // @@protoc_insertion_point(field_mutable:lnrpc.WatchOnlyAccount.xpub)
  return _s;
}
inline const std::string& WatchOnlyAccount::_internal_xpub() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.xpub_.Get();
}
inline void WatchOnlyAccount::_internal_set_xpub(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xpub_.Set(value, GetArena());
}
inline std::string* WatchOnlyAccount::_internal_mutable_xpub() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.xpub_.Mutable( GetArena());
}
inline std::string* WatchOnlyAccount::release_xpub() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.WatchOnlyAccount.xpub)
  return _impl_.xpub_.Release();
}
inline void WatchOnlyAccount::set_allocated_xpub(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.xpub_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.xpub_.IsDefault()) {
          _impl_.xpub_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.WatchOnlyAccount.xpub)
}

// -------------------------------------------------------------------

// UnlockWalletRequest

// bytes wallet_password = 1;
inline void UnlockWalletRequest::clear_wallet_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wallet_password_.ClearToEmpty();
}
inline const std::string& UnlockWalletRequest::wallet_password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.UnlockWalletRequest.wallet_password)
  return _internal_wallet_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void UnlockWalletRequest::set_wallet_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wallet_password_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.UnlockWalletRequest.wallet_password)
}
inline std::string* UnlockWalletRequest::mutable_wallet_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_wallet_password();
  // @@protoc_insertion_point(field_mutable:lnrpc.UnlockWalletRequest.wallet_password)
  return _s;
}
inline const std::string& UnlockWalletRequest::_internal_wallet_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.wallet_password_.Get();
}
inline void UnlockWalletRequest::_internal_set_wallet_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wallet_password_.Set(value, GetArena());
}
inline std::string* UnlockWalletRequest::_internal_mutable_wallet_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.wallet_password_.Mutable( GetArena());
}
inline std::string* UnlockWalletRequest::release_wallet_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.UnlockWalletRequest.wallet_password)
  return _impl_.wallet_password_.Release();
}
inline void UnlockWalletRequest::set_allocated_wallet_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.wallet_password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.wallet_password_.IsDefault()) {
          _impl_.wallet_password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.UnlockWalletRequest.wallet_password)
}

// int32 recovery_window = 2;
inline void UnlockWalletRequest::clear_recovery_window() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_window_ = 0;
}
inline ::int32_t UnlockWalletRequest::recovery_window() const {
  // @@protoc_insertion_point(field_get:lnrpc.UnlockWalletRequest.recovery_window)
  return _internal_recovery_window();
}
inline void UnlockWalletRequest::set_recovery_window(::int32_t value) {
  _internal_set_recovery_window(value);
  // @@protoc_insertion_point(field_set:lnrpc.UnlockWalletRequest.recovery_window)
}
inline ::int32_t UnlockWalletRequest::_internal_recovery_window() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.recovery_window_;
}
inline void UnlockWalletRequest::_internal_set_recovery_window(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.recovery_window_ = value;
}

// .lnrpc.ChanBackupSnapshot channel_backups = 3;
inline bool UnlockWalletRequest::has_channel_backups() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.channel_backups_ != nullptr);
  return value;
}
inline const ::lnrpc::ChanBackupSnapshot& UnlockWalletRequest::_internal_channel_backups() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::lnrpc::ChanBackupSnapshot* p = _impl_.channel_backups_;
  return p != nullptr ? *p : reinterpret_cast<const ::lnrpc::ChanBackupSnapshot&>(::lnrpc::_ChanBackupSnapshot_default_instance_);
}
inline const ::lnrpc::ChanBackupSnapshot& UnlockWalletRequest::channel_backups() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.UnlockWalletRequest.channel_backups)
  return _internal_channel_backups();
}
inline void UnlockWalletRequest::unsafe_arena_set_allocated_channel_backups(::lnrpc::ChanBackupSnapshot* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.channel_backups_);
  }
  _impl_.channel_backups_ = reinterpret_cast<::lnrpc::ChanBackupSnapshot*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:lnrpc.UnlockWalletRequest.channel_backups)
}
inline ::lnrpc::ChanBackupSnapshot* UnlockWalletRequest::release_channel_backups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lnrpc::ChanBackupSnapshot* released = _impl_.channel_backups_;
  _impl_.channel_backups_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::lnrpc::ChanBackupSnapshot* UnlockWalletRequest::unsafe_arena_release_channel_backups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.UnlockWalletRequest.channel_backups)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::lnrpc::ChanBackupSnapshot* temp = _impl_.channel_backups_;
  _impl_.channel_backups_ = nullptr;
  return temp;
}
inline ::lnrpc::ChanBackupSnapshot* UnlockWalletRequest::_internal_mutable_channel_backups() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.channel_backups_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::lnrpc::ChanBackupSnapshot>(GetArena());
    _impl_.channel_backups_ = reinterpret_cast<::lnrpc::ChanBackupSnapshot*>(p);
  }
  return _impl_.channel_backups_;
}
inline ::lnrpc::ChanBackupSnapshot* UnlockWalletRequest::mutable_channel_backups() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::lnrpc::ChanBackupSnapshot* _msg = _internal_mutable_channel_backups();
  // @@protoc_insertion_point(field_mutable:lnrpc.UnlockWalletRequest.channel_backups)
  return _msg;
}
inline void UnlockWalletRequest::set_allocated_channel_backups(::lnrpc::ChanBackupSnapshot* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.channel_backups_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.channel_backups_ = reinterpret_cast<::lnrpc::ChanBackupSnapshot*>(value);
  // @@protoc_insertion_point(field_set_allocated:lnrpc.UnlockWalletRequest.channel_backups)
}

// bool stateless_init = 4;
inline void UnlockWalletRequest::clear_stateless_init() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stateless_init_ = false;
}
inline bool UnlockWalletRequest::stateless_init() const {
  // @@protoc_insertion_point(field_get:lnrpc.UnlockWalletRequest.stateless_init)
  return _internal_stateless_init();
}
inline void UnlockWalletRequest::set_stateless_init(bool value) {
  _internal_set_stateless_init(value);
  // @@protoc_insertion_point(field_set:lnrpc.UnlockWalletRequest.stateless_init)
}
inline bool UnlockWalletRequest::_internal_stateless_init() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stateless_init_;
}
inline void UnlockWalletRequest::_internal_set_stateless_init(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stateless_init_ = value;
}

// -------------------------------------------------------------------

// UnlockWalletResponse

// -------------------------------------------------------------------

// ChangePasswordRequest

// bytes current_password = 1;
inline void ChangePasswordRequest::clear_current_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_password_.ClearToEmpty();
}
inline const std::string& ChangePasswordRequest::current_password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.ChangePasswordRequest.current_password)
  return _internal_current_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangePasswordRequest::set_current_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_password_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.ChangePasswordRequest.current_password)
}
inline std::string* ChangePasswordRequest::mutable_current_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_current_password();
  // @@protoc_insertion_point(field_mutable:lnrpc.ChangePasswordRequest.current_password)
  return _s;
}
inline const std::string& ChangePasswordRequest::_internal_current_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.current_password_.Get();
}
inline void ChangePasswordRequest::_internal_set_current_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_password_.Set(value, GetArena());
}
inline std::string* ChangePasswordRequest::_internal_mutable_current_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.current_password_.Mutable( GetArena());
}
inline std::string* ChangePasswordRequest::release_current_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.ChangePasswordRequest.current_password)
  return _impl_.current_password_.Release();
}
inline void ChangePasswordRequest::set_allocated_current_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.current_password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.current_password_.IsDefault()) {
          _impl_.current_password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.ChangePasswordRequest.current_password)
}

// bytes new_password = 2;
inline void ChangePasswordRequest::clear_new_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_password_.ClearToEmpty();
}
inline const std::string& ChangePasswordRequest::new_password() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.ChangePasswordRequest.new_password)
  return _internal_new_password();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangePasswordRequest::set_new_password(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_password_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.ChangePasswordRequest.new_password)
}
inline std::string* ChangePasswordRequest::mutable_new_password() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_new_password();
  // @@protoc_insertion_point(field_mutable:lnrpc.ChangePasswordRequest.new_password)
  return _s;
}
inline const std::string& ChangePasswordRequest::_internal_new_password() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_password_.Get();
}
inline void ChangePasswordRequest::_internal_set_new_password(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_password_.Set(value, GetArena());
}
inline std::string* ChangePasswordRequest::_internal_mutable_new_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.new_password_.Mutable( GetArena());
}
inline std::string* ChangePasswordRequest::release_new_password() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.ChangePasswordRequest.new_password)
  return _impl_.new_password_.Release();
}
inline void ChangePasswordRequest::set_allocated_new_password(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_password_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.new_password_.IsDefault()) {
          _impl_.new_password_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.ChangePasswordRequest.new_password)
}

// bool stateless_init = 3;
inline void ChangePasswordRequest::clear_stateless_init() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stateless_init_ = false;
}
inline bool ChangePasswordRequest::stateless_init() const {
  // @@protoc_insertion_point(field_get:lnrpc.ChangePasswordRequest.stateless_init)
  return _internal_stateless_init();
}
inline void ChangePasswordRequest::set_stateless_init(bool value) {
  _internal_set_stateless_init(value);
  // @@protoc_insertion_point(field_set:lnrpc.ChangePasswordRequest.stateless_init)
}
inline bool ChangePasswordRequest::_internal_stateless_init() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.stateless_init_;
}
inline void ChangePasswordRequest::_internal_set_stateless_init(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.stateless_init_ = value;
}

// bool new_macaroon_root_key = 4;
inline void ChangePasswordRequest::clear_new_macaroon_root_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_macaroon_root_key_ = false;
}
inline bool ChangePasswordRequest::new_macaroon_root_key() const {
  // @@protoc_insertion_point(field_get:lnrpc.ChangePasswordRequest.new_macaroon_root_key)
  return _internal_new_macaroon_root_key();
}
inline void ChangePasswordRequest::set_new_macaroon_root_key(bool value) {
  _internal_set_new_macaroon_root_key(value);
  // @@protoc_insertion_point(field_set:lnrpc.ChangePasswordRequest.new_macaroon_root_key)
}
inline bool ChangePasswordRequest::_internal_new_macaroon_root_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.new_macaroon_root_key_;
}
inline void ChangePasswordRequest::_internal_set_new_macaroon_root_key(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.new_macaroon_root_key_ = value;
}

// -------------------------------------------------------------------

// ChangePasswordResponse

// bytes admin_macaroon = 1;
inline void ChangePasswordResponse::clear_admin_macaroon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_macaroon_.ClearToEmpty();
}
inline const std::string& ChangePasswordResponse::admin_macaroon() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:lnrpc.ChangePasswordResponse.admin_macaroon)
  return _internal_admin_macaroon();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void ChangePasswordResponse::set_admin_macaroon(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_macaroon_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:lnrpc.ChangePasswordResponse.admin_macaroon)
}
inline std::string* ChangePasswordResponse::mutable_admin_macaroon() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_admin_macaroon();
  // @@protoc_insertion_point(field_mutable:lnrpc.ChangePasswordResponse.admin_macaroon)
  return _s;
}
inline const std::string& ChangePasswordResponse::_internal_admin_macaroon() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.admin_macaroon_.Get();
}
inline void ChangePasswordResponse::_internal_set_admin_macaroon(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_macaroon_.Set(value, GetArena());
}
inline std::string* ChangePasswordResponse::_internal_mutable_admin_macaroon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.admin_macaroon_.Mutable( GetArena());
}
inline std::string* ChangePasswordResponse::release_admin_macaroon() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:lnrpc.ChangePasswordResponse.admin_macaroon)
  return _impl_.admin_macaroon_.Release();
}
inline void ChangePasswordResponse::set_allocated_admin_macaroon(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.admin_macaroon_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.admin_macaroon_.IsDefault()) {
          _impl_.admin_macaroon_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:lnrpc.ChangePasswordResponse.admin_macaroon)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace lnrpc


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_walletunlocker_2eproto_2epb_2eh
