// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: signer.proto
// Protobuf C++ Version: 5.28.2

#ifndef GOOGLE_PROTOBUF_INCLUDED_signer_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_signer_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028002
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_signer_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_signer_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_signer_2eproto;
namespace signrpc {
class InputScript;
struct InputScriptDefaultTypeInternal;
extern InputScriptDefaultTypeInternal _InputScript_default_instance_;
class InputScriptResp;
struct InputScriptRespDefaultTypeInternal;
extern InputScriptRespDefaultTypeInternal _InputScriptResp_default_instance_;
class KeyDescriptor;
struct KeyDescriptorDefaultTypeInternal;
extern KeyDescriptorDefaultTypeInternal _KeyDescriptor_default_instance_;
class KeyLocator;
struct KeyLocatorDefaultTypeInternal;
extern KeyLocatorDefaultTypeInternal _KeyLocator_default_instance_;
class MuSig2CleanupRequest;
struct MuSig2CleanupRequestDefaultTypeInternal;
extern MuSig2CleanupRequestDefaultTypeInternal _MuSig2CleanupRequest_default_instance_;
class MuSig2CleanupResponse;
struct MuSig2CleanupResponseDefaultTypeInternal;
extern MuSig2CleanupResponseDefaultTypeInternal _MuSig2CleanupResponse_default_instance_;
class MuSig2CombineKeysRequest;
struct MuSig2CombineKeysRequestDefaultTypeInternal;
extern MuSig2CombineKeysRequestDefaultTypeInternal _MuSig2CombineKeysRequest_default_instance_;
class MuSig2CombineKeysResponse;
struct MuSig2CombineKeysResponseDefaultTypeInternal;
extern MuSig2CombineKeysResponseDefaultTypeInternal _MuSig2CombineKeysResponse_default_instance_;
class MuSig2CombineSigRequest;
struct MuSig2CombineSigRequestDefaultTypeInternal;
extern MuSig2CombineSigRequestDefaultTypeInternal _MuSig2CombineSigRequest_default_instance_;
class MuSig2CombineSigResponse;
struct MuSig2CombineSigResponseDefaultTypeInternal;
extern MuSig2CombineSigResponseDefaultTypeInternal _MuSig2CombineSigResponse_default_instance_;
class MuSig2RegisterNoncesRequest;
struct MuSig2RegisterNoncesRequestDefaultTypeInternal;
extern MuSig2RegisterNoncesRequestDefaultTypeInternal _MuSig2RegisterNoncesRequest_default_instance_;
class MuSig2RegisterNoncesResponse;
struct MuSig2RegisterNoncesResponseDefaultTypeInternal;
extern MuSig2RegisterNoncesResponseDefaultTypeInternal _MuSig2RegisterNoncesResponse_default_instance_;
class MuSig2SessionRequest;
struct MuSig2SessionRequestDefaultTypeInternal;
extern MuSig2SessionRequestDefaultTypeInternal _MuSig2SessionRequest_default_instance_;
class MuSig2SessionResponse;
struct MuSig2SessionResponseDefaultTypeInternal;
extern MuSig2SessionResponseDefaultTypeInternal _MuSig2SessionResponse_default_instance_;
class MuSig2SignRequest;
struct MuSig2SignRequestDefaultTypeInternal;
extern MuSig2SignRequestDefaultTypeInternal _MuSig2SignRequest_default_instance_;
class MuSig2SignResponse;
struct MuSig2SignResponseDefaultTypeInternal;
extern MuSig2SignResponseDefaultTypeInternal _MuSig2SignResponse_default_instance_;
class SharedKeyRequest;
struct SharedKeyRequestDefaultTypeInternal;
extern SharedKeyRequestDefaultTypeInternal _SharedKeyRequest_default_instance_;
class SharedKeyResponse;
struct SharedKeyResponseDefaultTypeInternal;
extern SharedKeyResponseDefaultTypeInternal _SharedKeyResponse_default_instance_;
class SignDescriptor;
struct SignDescriptorDefaultTypeInternal;
extern SignDescriptorDefaultTypeInternal _SignDescriptor_default_instance_;
class SignMessageReq;
struct SignMessageReqDefaultTypeInternal;
extern SignMessageReqDefaultTypeInternal _SignMessageReq_default_instance_;
class SignMessageResp;
struct SignMessageRespDefaultTypeInternal;
extern SignMessageRespDefaultTypeInternal _SignMessageResp_default_instance_;
class SignReq;
struct SignReqDefaultTypeInternal;
extern SignReqDefaultTypeInternal _SignReq_default_instance_;
class SignResp;
struct SignRespDefaultTypeInternal;
extern SignRespDefaultTypeInternal _SignResp_default_instance_;
class TaprootTweakDesc;
struct TaprootTweakDescDefaultTypeInternal;
extern TaprootTweakDescDefaultTypeInternal _TaprootTweakDesc_default_instance_;
class TweakDesc;
struct TweakDescDefaultTypeInternal;
extern TweakDescDefaultTypeInternal _TweakDesc_default_instance_;
class TxOut;
struct TxOutDefaultTypeInternal;
extern TxOutDefaultTypeInternal _TxOut_default_instance_;
class VerifyMessageReq;
struct VerifyMessageReqDefaultTypeInternal;
extern VerifyMessageReqDefaultTypeInternal _VerifyMessageReq_default_instance_;
class VerifyMessageResp;
struct VerifyMessageRespDefaultTypeInternal;
extern VerifyMessageRespDefaultTypeInternal _VerifyMessageResp_default_instance_;
}  // namespace signrpc
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace signrpc {
enum SignMethod : int {
  SIGN_METHOD_WITNESS_V0 = 0,
  SIGN_METHOD_TAPROOT_KEY_SPEND_BIP0086 = 1,
  SIGN_METHOD_TAPROOT_KEY_SPEND = 2,
  SIGN_METHOD_TAPROOT_SCRIPT_SPEND = 3,
  SignMethod_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SignMethod_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SignMethod_IsValid(int value);
extern const uint32_t SignMethod_internal_data_[];
constexpr SignMethod SignMethod_MIN = static_cast<SignMethod>(0);
constexpr SignMethod SignMethod_MAX = static_cast<SignMethod>(3);
constexpr int SignMethod_ARRAYSIZE = 3 + 1;
const ::google::protobuf::EnumDescriptor*
SignMethod_descriptor();
template <typename T>
const std::string& SignMethod_Name(T value) {
  static_assert(std::is_same<T, SignMethod>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to SignMethod_Name().");
  return SignMethod_Name(static_cast<SignMethod>(value));
}
template <>
inline const std::string& SignMethod_Name(SignMethod value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SignMethod_descriptor,
                                                 0, 3>(
      static_cast<int>(value));
}
inline bool SignMethod_Parse(absl::string_view name, SignMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignMethod>(
      SignMethod_descriptor(), name, value);
}
enum MuSig2Version : int {
  MUSIG2_VERSION_UNDEFINED = 0,
  MUSIG2_VERSION_V040 = 1,
  MUSIG2_VERSION_V100RC2 = 2,
  MuSig2Version_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  MuSig2Version_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool MuSig2Version_IsValid(int value);
extern const uint32_t MuSig2Version_internal_data_[];
constexpr MuSig2Version MuSig2Version_MIN = static_cast<MuSig2Version>(0);
constexpr MuSig2Version MuSig2Version_MAX = static_cast<MuSig2Version>(2);
constexpr int MuSig2Version_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
MuSig2Version_descriptor();
template <typename T>
const std::string& MuSig2Version_Name(T value) {
  static_assert(std::is_same<T, MuSig2Version>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MuSig2Version_Name().");
  return MuSig2Version_Name(static_cast<MuSig2Version>(value));
}
template <>
inline const std::string& MuSig2Version_Name(MuSig2Version value) {
  return ::google::protobuf::internal::NameOfDenseEnum<MuSig2Version_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool MuSig2Version_Parse(absl::string_view name, MuSig2Version* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MuSig2Version>(
      MuSig2Version_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class VerifyMessageResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.VerifyMessageResp) */ {
 public:
  inline VerifyMessageResp() : VerifyMessageResp(nullptr) {}
  ~VerifyMessageResp() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VerifyMessageResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline VerifyMessageResp(const VerifyMessageResp& from) : VerifyMessageResp(nullptr, from) {}
  inline VerifyMessageResp(VerifyMessageResp&& from) noexcept
      : VerifyMessageResp(nullptr, std::move(from)) {}
  inline VerifyMessageResp& operator=(const VerifyMessageResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyMessageResp& operator=(VerifyMessageResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyMessageResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyMessageResp* internal_default_instance() {
    return reinterpret_cast<const VerifyMessageResp*>(
        &_VerifyMessageResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(VerifyMessageResp& a, VerifyMessageResp& b) { a.Swap(&b); }
  inline void Swap(VerifyMessageResp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyMessageResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyMessageResp* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<VerifyMessageResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VerifyMessageResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VerifyMessageResp& from) { VerifyMessageResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VerifyMessageResp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.VerifyMessageResp"; }

 protected:
  explicit VerifyMessageResp(::google::protobuf::Arena* arena);
  VerifyMessageResp(::google::protobuf::Arena* arena, const VerifyMessageResp& from);
  VerifyMessageResp(::google::protobuf::Arena* arena, VerifyMessageResp&& from) noexcept
      : VerifyMessageResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kValidFieldNumber = 1,
  };
  // bool valid = 1;
  void clear_valid() ;
  bool valid() const;
  void set_valid(bool value);

  private:
  bool _internal_valid() const;
  void _internal_set_valid(bool value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.VerifyMessageResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_VerifyMessageResp_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VerifyMessageResp& from_msg);
    bool valid_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class VerifyMessageReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.VerifyMessageReq) */ {
 public:
  inline VerifyMessageReq() : VerifyMessageReq(nullptr) {}
  ~VerifyMessageReq() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR VerifyMessageReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline VerifyMessageReq(const VerifyMessageReq& from) : VerifyMessageReq(nullptr, from) {}
  inline VerifyMessageReq(VerifyMessageReq&& from) noexcept
      : VerifyMessageReq(nullptr, std::move(from)) {}
  inline VerifyMessageReq& operator=(const VerifyMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyMessageReq& operator=(VerifyMessageReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyMessageReq* internal_default_instance() {
    return reinterpret_cast<const VerifyMessageReq*>(
        &_VerifyMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(VerifyMessageReq& a, VerifyMessageReq& b) { a.Swap(&b); }
  inline void Swap(VerifyMessageReq* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyMessageReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyMessageReq* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<VerifyMessageReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const VerifyMessageReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const VerifyMessageReq& from) { VerifyMessageReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(VerifyMessageReq* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.VerifyMessageReq"; }

 protected:
  explicit VerifyMessageReq(::google::protobuf::Arena* arena);
  VerifyMessageReq(::google::protobuf::Arena* arena, const VerifyMessageReq& from);
  VerifyMessageReq(::google::protobuf::Arena* arena, VerifyMessageReq&& from) noexcept
      : VerifyMessageReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgFieldNumber = 1,
    kSignatureFieldNumber = 2,
    kPubkeyFieldNumber = 3,
    kTagFieldNumber = 5,
    kIsSchnorrSigFieldNumber = 4,
  };
  // bytes msg = 1;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* value);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // bytes signature = 2;
  void clear_signature() ;
  const std::string& signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* value);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // bytes pubkey = 3;
  void clear_pubkey() ;
  const std::string& pubkey() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pubkey(Arg_&& arg, Args_... args);
  std::string* mutable_pubkey();
  PROTOBUF_NODISCARD std::string* release_pubkey();
  void set_allocated_pubkey(std::string* value);

  private:
  const std::string& _internal_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pubkey(
      const std::string& value);
  std::string* _internal_mutable_pubkey();

  public:
  // bytes tag = 5;
  void clear_tag() ;
  const std::string& tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tag(Arg_&& arg, Args_... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* value);

  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(
      const std::string& value);
  std::string* _internal_mutable_tag();

  public:
  // bool is_schnorr_sig = 4;
  void clear_is_schnorr_sig() ;
  bool is_schnorr_sig() const;
  void set_is_schnorr_sig(bool value);

  private:
  bool _internal_is_schnorr_sig() const;
  void _internal_set_is_schnorr_sig(bool value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.VerifyMessageReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_VerifyMessageReq_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const VerifyMessageReq& from_msg);
    ::google::protobuf::internal::ArenaStringPtr msg_;
    ::google::protobuf::internal::ArenaStringPtr signature_;
    ::google::protobuf::internal::ArenaStringPtr pubkey_;
    ::google::protobuf::internal::ArenaStringPtr tag_;
    bool is_schnorr_sig_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class TxOut final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.TxOut) */ {
 public:
  inline TxOut() : TxOut(nullptr) {}
  ~TxOut() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TxOut(
      ::google::protobuf::internal::ConstantInitialized);

  inline TxOut(const TxOut& from) : TxOut(nullptr, from) {}
  inline TxOut(TxOut&& from) noexcept
      : TxOut(nullptr, std::move(from)) {}
  inline TxOut& operator=(const TxOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxOut& operator=(TxOut&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxOut& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxOut* internal_default_instance() {
    return reinterpret_cast<const TxOut*>(
        &_TxOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(TxOut& a, TxOut& b) { a.Swap(&b); }
  inline void Swap(TxOut* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxOut* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxOut* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TxOut>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TxOut& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TxOut& from) { TxOut::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TxOut* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.TxOut"; }

 protected:
  explicit TxOut(::google::protobuf::Arena* arena);
  TxOut(::google::protobuf::Arena* arena, const TxOut& from);
  TxOut(::google::protobuf::Arena* arena, TxOut&& from) noexcept
      : TxOut(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPkScriptFieldNumber = 2,
    kValueFieldNumber = 1,
  };
  // bytes pk_script = 2;
  void clear_pk_script() ;
  const std::string& pk_script() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pk_script(Arg_&& arg, Args_... args);
  std::string* mutable_pk_script();
  PROTOBUF_NODISCARD std::string* release_pk_script();
  void set_allocated_pk_script(std::string* value);

  private:
  const std::string& _internal_pk_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pk_script(
      const std::string& value);
  std::string* _internal_mutable_pk_script();

  public:
  // int64 value = 1;
  void clear_value() ;
  ::int64_t value() const;
  void set_value(::int64_t value);

  private:
  ::int64_t _internal_value() const;
  void _internal_set_value(::int64_t value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.TxOut)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TxOut_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TxOut& from_msg);
    ::google::protobuf::internal::ArenaStringPtr pk_script_;
    ::int64_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class TweakDesc final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.TweakDesc) */ {
 public:
  inline TweakDesc() : TweakDesc(nullptr) {}
  ~TweakDesc() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TweakDesc(
      ::google::protobuf::internal::ConstantInitialized);

  inline TweakDesc(const TweakDesc& from) : TweakDesc(nullptr, from) {}
  inline TweakDesc(TweakDesc&& from) noexcept
      : TweakDesc(nullptr, std::move(from)) {}
  inline TweakDesc& operator=(const TweakDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline TweakDesc& operator=(TweakDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TweakDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const TweakDesc* internal_default_instance() {
    return reinterpret_cast<const TweakDesc*>(
        &_TweakDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(TweakDesc& a, TweakDesc& b) { a.Swap(&b); }
  inline void Swap(TweakDesc* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TweakDesc* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TweakDesc* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TweakDesc>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TweakDesc& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TweakDesc& from) { TweakDesc::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TweakDesc* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.TweakDesc"; }

 protected:
  explicit TweakDesc(::google::protobuf::Arena* arena);
  TweakDesc(::google::protobuf::Arena* arena, const TweakDesc& from);
  TweakDesc(::google::protobuf::Arena* arena, TweakDesc&& from) noexcept
      : TweakDesc(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTweakFieldNumber = 1,
    kIsXOnlyFieldNumber = 2,
  };
  // bytes tweak = 1;
  void clear_tweak() ;
  const std::string& tweak() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tweak(Arg_&& arg, Args_... args);
  std::string* mutable_tweak();
  PROTOBUF_NODISCARD std::string* release_tweak();
  void set_allocated_tweak(std::string* value);

  private:
  const std::string& _internal_tweak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tweak(
      const std::string& value);
  std::string* _internal_mutable_tweak();

  public:
  // bool is_x_only = 2;
  void clear_is_x_only() ;
  bool is_x_only() const;
  void set_is_x_only(bool value);

  private:
  bool _internal_is_x_only() const;
  void _internal_set_is_x_only(bool value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.TweakDesc)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TweakDesc_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TweakDesc& from_msg);
    ::google::protobuf::internal::ArenaStringPtr tweak_;
    bool is_x_only_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class TaprootTweakDesc final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.TaprootTweakDesc) */ {
 public:
  inline TaprootTweakDesc() : TaprootTweakDesc(nullptr) {}
  ~TaprootTweakDesc() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TaprootTweakDesc(
      ::google::protobuf::internal::ConstantInitialized);

  inline TaprootTweakDesc(const TaprootTweakDesc& from) : TaprootTweakDesc(nullptr, from) {}
  inline TaprootTweakDesc(TaprootTweakDesc&& from) noexcept
      : TaprootTweakDesc(nullptr, std::move(from)) {}
  inline TaprootTweakDesc& operator=(const TaprootTweakDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline TaprootTweakDesc& operator=(TaprootTweakDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TaprootTweakDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const TaprootTweakDesc* internal_default_instance() {
    return reinterpret_cast<const TaprootTweakDesc*>(
        &_TaprootTweakDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(TaprootTweakDesc& a, TaprootTweakDesc& b) { a.Swap(&b); }
  inline void Swap(TaprootTweakDesc* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TaprootTweakDesc* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TaprootTweakDesc* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<TaprootTweakDesc>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TaprootTweakDesc& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TaprootTweakDesc& from) { TaprootTweakDesc::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(TaprootTweakDesc* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.TaprootTweakDesc"; }

 protected:
  explicit TaprootTweakDesc(::google::protobuf::Arena* arena);
  TaprootTweakDesc(::google::protobuf::Arena* arena, const TaprootTweakDesc& from);
  TaprootTweakDesc(::google::protobuf::Arena* arena, TaprootTweakDesc&& from) noexcept
      : TaprootTweakDesc(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kScriptRootFieldNumber = 1,
    kKeySpendOnlyFieldNumber = 2,
  };
  // bytes script_root = 1;
  void clear_script_root() ;
  const std::string& script_root() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_script_root(Arg_&& arg, Args_... args);
  std::string* mutable_script_root();
  PROTOBUF_NODISCARD std::string* release_script_root();
  void set_allocated_script_root(std::string* value);

  private:
  const std::string& _internal_script_root() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script_root(
      const std::string& value);
  std::string* _internal_mutable_script_root();

  public:
  // bool key_spend_only = 2;
  void clear_key_spend_only() ;
  bool key_spend_only() const;
  void set_key_spend_only(bool value);

  private:
  bool _internal_key_spend_only() const;
  void _internal_set_key_spend_only(bool value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.TaprootTweakDesc)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_TaprootTweakDesc_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TaprootTweakDesc& from_msg);
    ::google::protobuf::internal::ArenaStringPtr script_root_;
    bool key_spend_only_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class SignResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.SignResp) */ {
 public:
  inline SignResp() : SignResp(nullptr) {}
  ~SignResp() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline SignResp(const SignResp& from) : SignResp(nullptr, from) {}
  inline SignResp(SignResp&& from) noexcept
      : SignResp(nullptr, std::move(from)) {}
  inline SignResp& operator=(const SignResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignResp& operator=(SignResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignResp* internal_default_instance() {
    return reinterpret_cast<const SignResp*>(
        &_SignResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(SignResp& a, SignResp& b) { a.Swap(&b); }
  inline void Swap(SignResp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignResp* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SignResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SignResp& from) { SignResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SignResp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.SignResp"; }

 protected:
  explicit SignResp(::google::protobuf::Arena* arena);
  SignResp(::google::protobuf::Arena* arena, const SignResp& from);
  SignResp(::google::protobuf::Arena* arena, SignResp&& from) noexcept
      : SignResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRawSigsFieldNumber = 1,
  };
  // repeated bytes raw_sigs = 1;
  int raw_sigs_size() const;
  private:
  int _internal_raw_sigs_size() const;

  public:
  void clear_raw_sigs() ;
  const std::string& raw_sigs(int index) const;
  std::string* mutable_raw_sigs(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_sigs(int index, Arg_&& value, Args_... args);
  std::string* add_raw_sigs();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_raw_sigs(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& raw_sigs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_raw_sigs();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_raw_sigs() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_raw_sigs();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.SignResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SignResp_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SignResp& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> raw_sigs_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class SignMessageResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.SignMessageResp) */ {
 public:
  inline SignMessageResp() : SignMessageResp(nullptr) {}
  ~SignMessageResp() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignMessageResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline SignMessageResp(const SignMessageResp& from) : SignMessageResp(nullptr, from) {}
  inline SignMessageResp(SignMessageResp&& from) noexcept
      : SignMessageResp(nullptr, std::move(from)) {}
  inline SignMessageResp& operator=(const SignMessageResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignMessageResp& operator=(SignMessageResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignMessageResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignMessageResp* internal_default_instance() {
    return reinterpret_cast<const SignMessageResp*>(
        &_SignMessageResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(SignMessageResp& a, SignMessageResp& b) { a.Swap(&b); }
  inline void Swap(SignMessageResp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignMessageResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignMessageResp* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SignMessageResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignMessageResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SignMessageResp& from) { SignMessageResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SignMessageResp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.SignMessageResp"; }

 protected:
  explicit SignMessageResp(::google::protobuf::Arena* arena);
  SignMessageResp(::google::protobuf::Arena* arena, const SignMessageResp& from);
  SignMessageResp(::google::protobuf::Arena* arena, SignMessageResp&& from) noexcept
      : SignMessageResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSignatureFieldNumber = 1,
  };
  // bytes signature = 1;
  void clear_signature() ;
  const std::string& signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_signature(Arg_&& arg, Args_... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* value);

  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(
      const std::string& value);
  std::string* _internal_mutable_signature();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.SignMessageResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SignMessageResp_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SignMessageResp& from_msg);
    ::google::protobuf::internal::ArenaStringPtr signature_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class SharedKeyResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.SharedKeyResponse) */ {
 public:
  inline SharedKeyResponse() : SharedKeyResponse(nullptr) {}
  ~SharedKeyResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SharedKeyResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline SharedKeyResponse(const SharedKeyResponse& from) : SharedKeyResponse(nullptr, from) {}
  inline SharedKeyResponse(SharedKeyResponse&& from) noexcept
      : SharedKeyResponse(nullptr, std::move(from)) {}
  inline SharedKeyResponse& operator=(const SharedKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharedKeyResponse& operator=(SharedKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SharedKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SharedKeyResponse* internal_default_instance() {
    return reinterpret_cast<const SharedKeyResponse*>(
        &_SharedKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SharedKeyResponse& a, SharedKeyResponse& b) { a.Swap(&b); }
  inline void Swap(SharedKeyResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharedKeyResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharedKeyResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SharedKeyResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SharedKeyResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SharedKeyResponse& from) { SharedKeyResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SharedKeyResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.SharedKeyResponse"; }

 protected:
  explicit SharedKeyResponse(::google::protobuf::Arena* arena);
  SharedKeyResponse(::google::protobuf::Arena* arena, const SharedKeyResponse& from);
  SharedKeyResponse(::google::protobuf::Arena* arena, SharedKeyResponse&& from) noexcept
      : SharedKeyResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSharedKeyFieldNumber = 1,
  };
  // bytes shared_key = 1;
  void clear_shared_key() ;
  const std::string& shared_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shared_key(Arg_&& arg, Args_... args);
  std::string* mutable_shared_key();
  PROTOBUF_NODISCARD std::string* release_shared_key();
  void set_allocated_shared_key(std::string* value);

  private:
  const std::string& _internal_shared_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shared_key(
      const std::string& value);
  std::string* _internal_mutable_shared_key();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.SharedKeyResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SharedKeyResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SharedKeyResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr shared_key_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2SignResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2SignResponse) */ {
 public:
  inline MuSig2SignResponse() : MuSig2SignResponse(nullptr) {}
  ~MuSig2SignResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2SignResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2SignResponse(const MuSig2SignResponse& from) : MuSig2SignResponse(nullptr, from) {}
  inline MuSig2SignResponse(MuSig2SignResponse&& from) noexcept
      : MuSig2SignResponse(nullptr, std::move(from)) {}
  inline MuSig2SignResponse& operator=(const MuSig2SignResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2SignResponse& operator=(MuSig2SignResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2SignResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2SignResponse* internal_default_instance() {
    return reinterpret_cast<const MuSig2SignResponse*>(
        &_MuSig2SignResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(MuSig2SignResponse& a, MuSig2SignResponse& b) { a.Swap(&b); }
  inline void Swap(MuSig2SignResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2SignResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2SignResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2SignResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2SignResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2SignResponse& from) { MuSig2SignResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2SignResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2SignResponse"; }

 protected:
  explicit MuSig2SignResponse(::google::protobuf::Arena* arena);
  MuSig2SignResponse(::google::protobuf::Arena* arena, const MuSig2SignResponse& from);
  MuSig2SignResponse(::google::protobuf::Arena* arena, MuSig2SignResponse&& from) noexcept
      : MuSig2SignResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kLocalPartialSignatureFieldNumber = 1,
  };
  // bytes local_partial_signature = 1;
  void clear_local_partial_signature() ;
  const std::string& local_partial_signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_local_partial_signature(Arg_&& arg, Args_... args);
  std::string* mutable_local_partial_signature();
  PROTOBUF_NODISCARD std::string* release_local_partial_signature();
  void set_allocated_local_partial_signature(std::string* value);

  private:
  const std::string& _internal_local_partial_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_partial_signature(
      const std::string& value);
  std::string* _internal_mutable_local_partial_signature();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2SignResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2SignResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2SignResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr local_partial_signature_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2SignRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2SignRequest) */ {
 public:
  inline MuSig2SignRequest() : MuSig2SignRequest(nullptr) {}
  ~MuSig2SignRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2SignRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2SignRequest(const MuSig2SignRequest& from) : MuSig2SignRequest(nullptr, from) {}
  inline MuSig2SignRequest(MuSig2SignRequest&& from) noexcept
      : MuSig2SignRequest(nullptr, std::move(from)) {}
  inline MuSig2SignRequest& operator=(const MuSig2SignRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2SignRequest& operator=(MuSig2SignRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2SignRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2SignRequest* internal_default_instance() {
    return reinterpret_cast<const MuSig2SignRequest*>(
        &_MuSig2SignRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(MuSig2SignRequest& a, MuSig2SignRequest& b) { a.Swap(&b); }
  inline void Swap(MuSig2SignRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2SignRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2SignRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2SignRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2SignRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2SignRequest& from) { MuSig2SignRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2SignRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2SignRequest"; }

 protected:
  explicit MuSig2SignRequest(::google::protobuf::Arena* arena);
  MuSig2SignRequest(::google::protobuf::Arena* arena, const MuSig2SignRequest& from);
  MuSig2SignRequest(::google::protobuf::Arena* arena, MuSig2SignRequest&& from) noexcept
      : MuSig2SignRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionIdFieldNumber = 1,
    kMessageDigestFieldNumber = 2,
    kCleanupFieldNumber = 3,
  };
  // bytes session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // bytes message_digest = 2;
  void clear_message_digest() ;
  const std::string& message_digest() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_message_digest(Arg_&& arg, Args_... args);
  std::string* mutable_message_digest();
  PROTOBUF_NODISCARD std::string* release_message_digest();
  void set_allocated_message_digest(std::string* value);

  private:
  const std::string& _internal_message_digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_digest(
      const std::string& value);
  std::string* _internal_mutable_message_digest();

  public:
  // bool cleanup = 3;
  void clear_cleanup() ;
  bool cleanup() const;
  void set_cleanup(bool value);

  private:
  bool _internal_cleanup() const;
  void _internal_set_cleanup(bool value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2SignRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2SignRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2SignRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr message_digest_;
    bool cleanup_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2SessionResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2SessionResponse) */ {
 public:
  inline MuSig2SessionResponse() : MuSig2SessionResponse(nullptr) {}
  ~MuSig2SessionResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2SessionResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2SessionResponse(const MuSig2SessionResponse& from) : MuSig2SessionResponse(nullptr, from) {}
  inline MuSig2SessionResponse(MuSig2SessionResponse&& from) noexcept
      : MuSig2SessionResponse(nullptr, std::move(from)) {}
  inline MuSig2SessionResponse& operator=(const MuSig2SessionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2SessionResponse& operator=(MuSig2SessionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2SessionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2SessionResponse* internal_default_instance() {
    return reinterpret_cast<const MuSig2SessionResponse*>(
        &_MuSig2SessionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(MuSig2SessionResponse& a, MuSig2SessionResponse& b) { a.Swap(&b); }
  inline void Swap(MuSig2SessionResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2SessionResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2SessionResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2SessionResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2SessionResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2SessionResponse& from) { MuSig2SessionResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2SessionResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2SessionResponse"; }

 protected:
  explicit MuSig2SessionResponse(::google::protobuf::Arena* arena);
  MuSig2SessionResponse(::google::protobuf::Arena* arena, const MuSig2SessionResponse& from);
  MuSig2SessionResponse(::google::protobuf::Arena* arena, MuSig2SessionResponse&& from) noexcept
      : MuSig2SessionResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionIdFieldNumber = 1,
    kCombinedKeyFieldNumber = 2,
    kTaprootInternalKeyFieldNumber = 3,
    kLocalPublicNoncesFieldNumber = 4,
    kHaveAllNoncesFieldNumber = 5,
    kVersionFieldNumber = 6,
  };
  // bytes session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // bytes combined_key = 2;
  void clear_combined_key() ;
  const std::string& combined_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_combined_key(Arg_&& arg, Args_... args);
  std::string* mutable_combined_key();
  PROTOBUF_NODISCARD std::string* release_combined_key();
  void set_allocated_combined_key(std::string* value);

  private:
  const std::string& _internal_combined_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_combined_key(
      const std::string& value);
  std::string* _internal_mutable_combined_key();

  public:
  // bytes taproot_internal_key = 3;
  void clear_taproot_internal_key() ;
  const std::string& taproot_internal_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taproot_internal_key(Arg_&& arg, Args_... args);
  std::string* mutable_taproot_internal_key();
  PROTOBUF_NODISCARD std::string* release_taproot_internal_key();
  void set_allocated_taproot_internal_key(std::string* value);

  private:
  const std::string& _internal_taproot_internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taproot_internal_key(
      const std::string& value);
  std::string* _internal_mutable_taproot_internal_key();

  public:
  // bytes local_public_nonces = 4;
  void clear_local_public_nonces() ;
  const std::string& local_public_nonces() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_local_public_nonces(Arg_&& arg, Args_... args);
  std::string* mutable_local_public_nonces();
  PROTOBUF_NODISCARD std::string* release_local_public_nonces();
  void set_allocated_local_public_nonces(std::string* value);

  private:
  const std::string& _internal_local_public_nonces() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_public_nonces(
      const std::string& value);
  std::string* _internal_mutable_local_public_nonces();

  public:
  // bool have_all_nonces = 5;
  void clear_have_all_nonces() ;
  bool have_all_nonces() const;
  void set_have_all_nonces(bool value);

  private:
  bool _internal_have_all_nonces() const;
  void _internal_set_have_all_nonces(bool value);

  public:
  // .signrpc.MuSig2Version version = 6;
  void clear_version() ;
  ::signrpc::MuSig2Version version() const;
  void set_version(::signrpc::MuSig2Version value);

  private:
  ::signrpc::MuSig2Version _internal_version() const;
  void _internal_set_version(::signrpc::MuSig2Version value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2SessionResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2SessionResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2SessionResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    ::google::protobuf::internal::ArenaStringPtr combined_key_;
    ::google::protobuf::internal::ArenaStringPtr taproot_internal_key_;
    ::google::protobuf::internal::ArenaStringPtr local_public_nonces_;
    bool have_all_nonces_;
    int version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2RegisterNoncesResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2RegisterNoncesResponse) */ {
 public:
  inline MuSig2RegisterNoncesResponse() : MuSig2RegisterNoncesResponse(nullptr) {}
  ~MuSig2RegisterNoncesResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2RegisterNoncesResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2RegisterNoncesResponse(const MuSig2RegisterNoncesResponse& from) : MuSig2RegisterNoncesResponse(nullptr, from) {}
  inline MuSig2RegisterNoncesResponse(MuSig2RegisterNoncesResponse&& from) noexcept
      : MuSig2RegisterNoncesResponse(nullptr, std::move(from)) {}
  inline MuSig2RegisterNoncesResponse& operator=(const MuSig2RegisterNoncesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2RegisterNoncesResponse& operator=(MuSig2RegisterNoncesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2RegisterNoncesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2RegisterNoncesResponse* internal_default_instance() {
    return reinterpret_cast<const MuSig2RegisterNoncesResponse*>(
        &_MuSig2RegisterNoncesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(MuSig2RegisterNoncesResponse& a, MuSig2RegisterNoncesResponse& b) { a.Swap(&b); }
  inline void Swap(MuSig2RegisterNoncesResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2RegisterNoncesResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2RegisterNoncesResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2RegisterNoncesResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2RegisterNoncesResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2RegisterNoncesResponse& from) { MuSig2RegisterNoncesResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2RegisterNoncesResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2RegisterNoncesResponse"; }

 protected:
  explicit MuSig2RegisterNoncesResponse(::google::protobuf::Arena* arena);
  MuSig2RegisterNoncesResponse(::google::protobuf::Arena* arena, const MuSig2RegisterNoncesResponse& from);
  MuSig2RegisterNoncesResponse(::google::protobuf::Arena* arena, MuSig2RegisterNoncesResponse&& from) noexcept
      : MuSig2RegisterNoncesResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHaveAllNoncesFieldNumber = 1,
  };
  // bool have_all_nonces = 1;
  void clear_have_all_nonces() ;
  bool have_all_nonces() const;
  void set_have_all_nonces(bool value);

  private:
  bool _internal_have_all_nonces() const;
  void _internal_set_have_all_nonces(bool value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2RegisterNoncesResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2RegisterNoncesResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2RegisterNoncesResponse& from_msg);
    bool have_all_nonces_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2RegisterNoncesRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2RegisterNoncesRequest) */ {
 public:
  inline MuSig2RegisterNoncesRequest() : MuSig2RegisterNoncesRequest(nullptr) {}
  ~MuSig2RegisterNoncesRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2RegisterNoncesRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2RegisterNoncesRequest(const MuSig2RegisterNoncesRequest& from) : MuSig2RegisterNoncesRequest(nullptr, from) {}
  inline MuSig2RegisterNoncesRequest(MuSig2RegisterNoncesRequest&& from) noexcept
      : MuSig2RegisterNoncesRequest(nullptr, std::move(from)) {}
  inline MuSig2RegisterNoncesRequest& operator=(const MuSig2RegisterNoncesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2RegisterNoncesRequest& operator=(MuSig2RegisterNoncesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2RegisterNoncesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2RegisterNoncesRequest* internal_default_instance() {
    return reinterpret_cast<const MuSig2RegisterNoncesRequest*>(
        &_MuSig2RegisterNoncesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(MuSig2RegisterNoncesRequest& a, MuSig2RegisterNoncesRequest& b) { a.Swap(&b); }
  inline void Swap(MuSig2RegisterNoncesRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2RegisterNoncesRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2RegisterNoncesRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2RegisterNoncesRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2RegisterNoncesRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2RegisterNoncesRequest& from) { MuSig2RegisterNoncesRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2RegisterNoncesRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2RegisterNoncesRequest"; }

 protected:
  explicit MuSig2RegisterNoncesRequest(::google::protobuf::Arena* arena);
  MuSig2RegisterNoncesRequest(::google::protobuf::Arena* arena, const MuSig2RegisterNoncesRequest& from);
  MuSig2RegisterNoncesRequest(::google::protobuf::Arena* arena, MuSig2RegisterNoncesRequest&& from) noexcept
      : MuSig2RegisterNoncesRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOtherSignerPublicNoncesFieldNumber = 3,
    kSessionIdFieldNumber = 1,
  };
  // repeated bytes other_signer_public_nonces = 3;
  int other_signer_public_nonces_size() const;
  private:
  int _internal_other_signer_public_nonces_size() const;

  public:
  void clear_other_signer_public_nonces() ;
  const std::string& other_signer_public_nonces(int index) const;
  std::string* mutable_other_signer_public_nonces(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_other_signer_public_nonces(int index, Arg_&& value, Args_... args);
  std::string* add_other_signer_public_nonces();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_other_signer_public_nonces(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& other_signer_public_nonces() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_other_signer_public_nonces();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_other_signer_public_nonces() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_other_signer_public_nonces();

  public:
  // bytes session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2RegisterNoncesRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2RegisterNoncesRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2RegisterNoncesRequest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> other_signer_public_nonces_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2CombineSigResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2CombineSigResponse) */ {
 public:
  inline MuSig2CombineSigResponse() : MuSig2CombineSigResponse(nullptr) {}
  ~MuSig2CombineSigResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2CombineSigResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2CombineSigResponse(const MuSig2CombineSigResponse& from) : MuSig2CombineSigResponse(nullptr, from) {}
  inline MuSig2CombineSigResponse(MuSig2CombineSigResponse&& from) noexcept
      : MuSig2CombineSigResponse(nullptr, std::move(from)) {}
  inline MuSig2CombineSigResponse& operator=(const MuSig2CombineSigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2CombineSigResponse& operator=(MuSig2CombineSigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2CombineSigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2CombineSigResponse* internal_default_instance() {
    return reinterpret_cast<const MuSig2CombineSigResponse*>(
        &_MuSig2CombineSigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(MuSig2CombineSigResponse& a, MuSig2CombineSigResponse& b) { a.Swap(&b); }
  inline void Swap(MuSig2CombineSigResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2CombineSigResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2CombineSigResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2CombineSigResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2CombineSigResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2CombineSigResponse& from) { MuSig2CombineSigResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2CombineSigResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2CombineSigResponse"; }

 protected:
  explicit MuSig2CombineSigResponse(::google::protobuf::Arena* arena);
  MuSig2CombineSigResponse(::google::protobuf::Arena* arena, const MuSig2CombineSigResponse& from);
  MuSig2CombineSigResponse(::google::protobuf::Arena* arena, MuSig2CombineSigResponse&& from) noexcept
      : MuSig2CombineSigResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFinalSignatureFieldNumber = 2,
    kHaveAllSignaturesFieldNumber = 1,
  };
  // bytes final_signature = 2;
  void clear_final_signature() ;
  const std::string& final_signature() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_final_signature(Arg_&& arg, Args_... args);
  std::string* mutable_final_signature();
  PROTOBUF_NODISCARD std::string* release_final_signature();
  void set_allocated_final_signature(std::string* value);

  private:
  const std::string& _internal_final_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_final_signature(
      const std::string& value);
  std::string* _internal_mutable_final_signature();

  public:
  // bool have_all_signatures = 1;
  void clear_have_all_signatures() ;
  bool have_all_signatures() const;
  void set_have_all_signatures(bool value);

  private:
  bool _internal_have_all_signatures() const;
  void _internal_set_have_all_signatures(bool value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2CombineSigResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2CombineSigResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2CombineSigResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr final_signature_;
    bool have_all_signatures_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2CombineSigRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2CombineSigRequest) */ {
 public:
  inline MuSig2CombineSigRequest() : MuSig2CombineSigRequest(nullptr) {}
  ~MuSig2CombineSigRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2CombineSigRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2CombineSigRequest(const MuSig2CombineSigRequest& from) : MuSig2CombineSigRequest(nullptr, from) {}
  inline MuSig2CombineSigRequest(MuSig2CombineSigRequest&& from) noexcept
      : MuSig2CombineSigRequest(nullptr, std::move(from)) {}
  inline MuSig2CombineSigRequest& operator=(const MuSig2CombineSigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2CombineSigRequest& operator=(MuSig2CombineSigRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2CombineSigRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2CombineSigRequest* internal_default_instance() {
    return reinterpret_cast<const MuSig2CombineSigRequest*>(
        &_MuSig2CombineSigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(MuSig2CombineSigRequest& a, MuSig2CombineSigRequest& b) { a.Swap(&b); }
  inline void Swap(MuSig2CombineSigRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2CombineSigRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2CombineSigRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2CombineSigRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2CombineSigRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2CombineSigRequest& from) { MuSig2CombineSigRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2CombineSigRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2CombineSigRequest"; }

 protected:
  explicit MuSig2CombineSigRequest(::google::protobuf::Arena* arena);
  MuSig2CombineSigRequest(::google::protobuf::Arena* arena, const MuSig2CombineSigRequest& from);
  MuSig2CombineSigRequest(::google::protobuf::Arena* arena, MuSig2CombineSigRequest&& from) noexcept
      : MuSig2CombineSigRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kOtherPartialSignaturesFieldNumber = 2,
    kSessionIdFieldNumber = 1,
  };
  // repeated bytes other_partial_signatures = 2;
  int other_partial_signatures_size() const;
  private:
  int _internal_other_partial_signatures_size() const;

  public:
  void clear_other_partial_signatures() ;
  const std::string& other_partial_signatures(int index) const;
  std::string* mutable_other_partial_signatures(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_other_partial_signatures(int index, Arg_&& value, Args_... args);
  std::string* add_other_partial_signatures();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_other_partial_signatures(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& other_partial_signatures() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_other_partial_signatures();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_other_partial_signatures() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_other_partial_signatures();

  public:
  // bytes session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2CombineSigRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2CombineSigRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2CombineSigRequest& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> other_partial_signatures_;
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2CombineKeysResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2CombineKeysResponse) */ {
 public:
  inline MuSig2CombineKeysResponse() : MuSig2CombineKeysResponse(nullptr) {}
  ~MuSig2CombineKeysResponse() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2CombineKeysResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2CombineKeysResponse(const MuSig2CombineKeysResponse& from) : MuSig2CombineKeysResponse(nullptr, from) {}
  inline MuSig2CombineKeysResponse(MuSig2CombineKeysResponse&& from) noexcept
      : MuSig2CombineKeysResponse(nullptr, std::move(from)) {}
  inline MuSig2CombineKeysResponse& operator=(const MuSig2CombineKeysResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2CombineKeysResponse& operator=(MuSig2CombineKeysResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2CombineKeysResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2CombineKeysResponse* internal_default_instance() {
    return reinterpret_cast<const MuSig2CombineKeysResponse*>(
        &_MuSig2CombineKeysResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(MuSig2CombineKeysResponse& a, MuSig2CombineKeysResponse& b) { a.Swap(&b); }
  inline void Swap(MuSig2CombineKeysResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2CombineKeysResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2CombineKeysResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2CombineKeysResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2CombineKeysResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2CombineKeysResponse& from) { MuSig2CombineKeysResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2CombineKeysResponse* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2CombineKeysResponse"; }

 protected:
  explicit MuSig2CombineKeysResponse(::google::protobuf::Arena* arena);
  MuSig2CombineKeysResponse(::google::protobuf::Arena* arena, const MuSig2CombineKeysResponse& from);
  MuSig2CombineKeysResponse(::google::protobuf::Arena* arena, MuSig2CombineKeysResponse&& from) noexcept
      : MuSig2CombineKeysResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCombinedKeyFieldNumber = 1,
    kTaprootInternalKeyFieldNumber = 2,
    kVersionFieldNumber = 4,
  };
  // bytes combined_key = 1;
  void clear_combined_key() ;
  const std::string& combined_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_combined_key(Arg_&& arg, Args_... args);
  std::string* mutable_combined_key();
  PROTOBUF_NODISCARD std::string* release_combined_key();
  void set_allocated_combined_key(std::string* value);

  private:
  const std::string& _internal_combined_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_combined_key(
      const std::string& value);
  std::string* _internal_mutable_combined_key();

  public:
  // bytes taproot_internal_key = 2;
  void clear_taproot_internal_key() ;
  const std::string& taproot_internal_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_taproot_internal_key(Arg_&& arg, Args_... args);
  std::string* mutable_taproot_internal_key();
  PROTOBUF_NODISCARD std::string* release_taproot_internal_key();
  void set_allocated_taproot_internal_key(std::string* value);

  private:
  const std::string& _internal_taproot_internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_taproot_internal_key(
      const std::string& value);
  std::string* _internal_mutable_taproot_internal_key();

  public:
  // .signrpc.MuSig2Version version = 4;
  void clear_version() ;
  ::signrpc::MuSig2Version version() const;
  void set_version(::signrpc::MuSig2Version value);

  private:
  ::signrpc::MuSig2Version _internal_version() const;
  void _internal_set_version(::signrpc::MuSig2Version value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2CombineKeysResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2CombineKeysResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2CombineKeysResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr combined_key_;
    ::google::protobuf::internal::ArenaStringPtr taproot_internal_key_;
    int version_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2CleanupResponse final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2CleanupResponse) */ {
 public:
  inline MuSig2CleanupResponse() : MuSig2CleanupResponse(nullptr) {}
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2CleanupResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2CleanupResponse(const MuSig2CleanupResponse& from) : MuSig2CleanupResponse(nullptr, from) {}
  inline MuSig2CleanupResponse(MuSig2CleanupResponse&& from) noexcept
      : MuSig2CleanupResponse(nullptr, std::move(from)) {}
  inline MuSig2CleanupResponse& operator=(const MuSig2CleanupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2CleanupResponse& operator=(MuSig2CleanupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2CleanupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2CleanupResponse* internal_default_instance() {
    return reinterpret_cast<const MuSig2CleanupResponse*>(
        &_MuSig2CleanupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(MuSig2CleanupResponse& a, MuSig2CleanupResponse& b) { a.Swap(&b); }
  inline void Swap(MuSig2CleanupResponse* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2CleanupResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2CleanupResponse* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<MuSig2CleanupResponse>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MuSig2CleanupResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MuSig2CleanupResponse& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2CleanupResponse"; }

 protected:
  explicit MuSig2CleanupResponse(::google::protobuf::Arena* arena);
  MuSig2CleanupResponse(::google::protobuf::Arena* arena, const MuSig2CleanupResponse& from);
  MuSig2CleanupResponse(::google::protobuf::Arena* arena, MuSig2CleanupResponse&& from) noexcept
      : MuSig2CleanupResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ZeroFieldsBase::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2CleanupResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2CleanupResponse_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2CleanupResponse& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2CleanupRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2CleanupRequest) */ {
 public:
  inline MuSig2CleanupRequest() : MuSig2CleanupRequest(nullptr) {}
  ~MuSig2CleanupRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2CleanupRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2CleanupRequest(const MuSig2CleanupRequest& from) : MuSig2CleanupRequest(nullptr, from) {}
  inline MuSig2CleanupRequest(MuSig2CleanupRequest&& from) noexcept
      : MuSig2CleanupRequest(nullptr, std::move(from)) {}
  inline MuSig2CleanupRequest& operator=(const MuSig2CleanupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2CleanupRequest& operator=(MuSig2CleanupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2CleanupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2CleanupRequest* internal_default_instance() {
    return reinterpret_cast<const MuSig2CleanupRequest*>(
        &_MuSig2CleanupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(MuSig2CleanupRequest& a, MuSig2CleanupRequest& b) { a.Swap(&b); }
  inline void Swap(MuSig2CleanupRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2CleanupRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2CleanupRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2CleanupRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2CleanupRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2CleanupRequest& from) { MuSig2CleanupRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2CleanupRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2CleanupRequest"; }

 protected:
  explicit MuSig2CleanupRequest(::google::protobuf::Arena* arena);
  MuSig2CleanupRequest(::google::protobuf::Arena* arena, const MuSig2CleanupRequest& from);
  MuSig2CleanupRequest(::google::protobuf::Arena* arena, MuSig2CleanupRequest&& from) noexcept
      : MuSig2CleanupRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSessionIdFieldNumber = 1,
  };
  // bytes session_id = 1;
  void clear_session_id() ;
  const std::string& session_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_session_id(Arg_&& arg, Args_... args);
  std::string* mutable_session_id();
  PROTOBUF_NODISCARD std::string* release_session_id();
  void set_allocated_session_id(std::string* value);

  private:
  const std::string& _internal_session_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_id(
      const std::string& value);
  std::string* _internal_mutable_session_id();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2CleanupRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2CleanupRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2CleanupRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr session_id_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class KeyLocator final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.KeyLocator) */ {
 public:
  inline KeyLocator() : KeyLocator(nullptr) {}
  ~KeyLocator() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyLocator(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyLocator(const KeyLocator& from) : KeyLocator(nullptr, from) {}
  inline KeyLocator(KeyLocator&& from) noexcept
      : KeyLocator(nullptr, std::move(from)) {}
  inline KeyLocator& operator=(const KeyLocator& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyLocator& operator=(KeyLocator&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyLocator& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyLocator* internal_default_instance() {
    return reinterpret_cast<const KeyLocator*>(
        &_KeyLocator_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(KeyLocator& a, KeyLocator& b) { a.Swap(&b); }
  inline void Swap(KeyLocator* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyLocator* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyLocator* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<KeyLocator>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyLocator& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyLocator& from) { KeyLocator::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyLocator* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.KeyLocator"; }

 protected:
  explicit KeyLocator(::google::protobuf::Arena* arena);
  KeyLocator(::google::protobuf::Arena* arena, const KeyLocator& from);
  KeyLocator(::google::protobuf::Arena* arena, KeyLocator&& from) noexcept
      : KeyLocator(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kKeyFamilyFieldNumber = 1,
    kKeyIndexFieldNumber = 2,
  };
  // int32 key_family = 1;
  void clear_key_family() ;
  ::int32_t key_family() const;
  void set_key_family(::int32_t value);

  private:
  ::int32_t _internal_key_family() const;
  void _internal_set_key_family(::int32_t value);

  public:
  // int32 key_index = 2;
  void clear_key_index() ;
  ::int32_t key_index() const;
  void set_key_index(::int32_t value);

  private:
  ::int32_t _internal_key_index() const;
  void _internal_set_key_index(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.KeyLocator)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_KeyLocator_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyLocator& from_msg);
    ::int32_t key_family_;
    ::int32_t key_index_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class InputScript final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.InputScript) */ {
 public:
  inline InputScript() : InputScript(nullptr) {}
  ~InputScript() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputScript(
      ::google::protobuf::internal::ConstantInitialized);

  inline InputScript(const InputScript& from) : InputScript(nullptr, from) {}
  inline InputScript(InputScript&& from) noexcept
      : InputScript(nullptr, std::move(from)) {}
  inline InputScript& operator=(const InputScript& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputScript& operator=(InputScript&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputScript& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputScript* internal_default_instance() {
    return reinterpret_cast<const InputScript*>(
        &_InputScript_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(InputScript& a, InputScript& b) { a.Swap(&b); }
  inline void Swap(InputScript* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputScript* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputScript* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<InputScript>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputScript& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputScript& from) { InputScript::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InputScript* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.InputScript"; }

 protected:
  explicit InputScript(::google::protobuf::Arena* arena);
  InputScript(::google::protobuf::Arena* arena, const InputScript& from);
  InputScript(::google::protobuf::Arena* arena, InputScript&& from) noexcept
      : InputScript(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kWitnessFieldNumber = 1,
    kSigScriptFieldNumber = 2,
  };
  // repeated bytes witness = 1;
  int witness_size() const;
  private:
  int _internal_witness_size() const;

  public:
  void clear_witness() ;
  const std::string& witness(int index) const;
  std::string* mutable_witness(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_witness(int index, Arg_&& value, Args_... args);
  std::string* add_witness();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_witness(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& witness() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_witness();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_witness() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_witness();

  public:
  // bytes sig_script = 2;
  void clear_sig_script() ;
  const std::string& sig_script() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_sig_script(Arg_&& arg, Args_... args);
  std::string* mutable_sig_script();
  PROTOBUF_NODISCARD std::string* release_sig_script();
  void set_allocated_sig_script(std::string* value);

  private:
  const std::string& _internal_sig_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sig_script(
      const std::string& value);
  std::string* _internal_mutable_sig_script();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.InputScript)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InputScript_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InputScript& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> witness_;
    ::google::protobuf::internal::ArenaStringPtr sig_script_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class SignMessageReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.SignMessageReq) */ {
 public:
  inline SignMessageReq() : SignMessageReq(nullptr) {}
  ~SignMessageReq() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignMessageReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline SignMessageReq(const SignMessageReq& from) : SignMessageReq(nullptr, from) {}
  inline SignMessageReq(SignMessageReq&& from) noexcept
      : SignMessageReq(nullptr, std::move(from)) {}
  inline SignMessageReq& operator=(const SignMessageReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignMessageReq& operator=(SignMessageReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignMessageReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignMessageReq* internal_default_instance() {
    return reinterpret_cast<const SignMessageReq*>(
        &_SignMessageReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(SignMessageReq& a, SignMessageReq& b) { a.Swap(&b); }
  inline void Swap(SignMessageReq* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignMessageReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignMessageReq* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SignMessageReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignMessageReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SignMessageReq& from) { SignMessageReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SignMessageReq* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.SignMessageReq"; }

 protected:
  explicit SignMessageReq(::google::protobuf::Arena* arena);
  SignMessageReq(::google::protobuf::Arena* arena, const SignMessageReq& from);
  SignMessageReq(::google::protobuf::Arena* arena, SignMessageReq&& from) noexcept
      : SignMessageReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kMsgFieldNumber = 1,
    kSchnorrSigTapTweakFieldNumber = 6,
    kTagFieldNumber = 7,
    kKeyLocFieldNumber = 2,
    kDoubleHashFieldNumber = 3,
    kCompactSigFieldNumber = 4,
    kSchnorrSigFieldNumber = 5,
  };
  // bytes msg = 1;
  void clear_msg() ;
  const std::string& msg() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_msg(Arg_&& arg, Args_... args);
  std::string* mutable_msg();
  PROTOBUF_NODISCARD std::string* release_msg();
  void set_allocated_msg(std::string* value);

  private:
  const std::string& _internal_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msg(
      const std::string& value);
  std::string* _internal_mutable_msg();

  public:
  // bytes schnorr_sig_tap_tweak = 6;
  void clear_schnorr_sig_tap_tweak() ;
  const std::string& schnorr_sig_tap_tweak() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_schnorr_sig_tap_tweak(Arg_&& arg, Args_... args);
  std::string* mutable_schnorr_sig_tap_tweak();
  PROTOBUF_NODISCARD std::string* release_schnorr_sig_tap_tweak();
  void set_allocated_schnorr_sig_tap_tweak(std::string* value);

  private:
  const std::string& _internal_schnorr_sig_tap_tweak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schnorr_sig_tap_tweak(
      const std::string& value);
  std::string* _internal_mutable_schnorr_sig_tap_tweak();

  public:
  // bytes tag = 7;
  void clear_tag() ;
  const std::string& tag() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tag(Arg_&& arg, Args_... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* value);

  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(
      const std::string& value);
  std::string* _internal_mutable_tag();

  public:
  // .signrpc.KeyLocator key_loc = 2;
  bool has_key_loc() const;
  void clear_key_loc() ;
  const ::signrpc::KeyLocator& key_loc() const;
  PROTOBUF_NODISCARD ::signrpc::KeyLocator* release_key_loc();
  ::signrpc::KeyLocator* mutable_key_loc();
  void set_allocated_key_loc(::signrpc::KeyLocator* value);
  void unsafe_arena_set_allocated_key_loc(::signrpc::KeyLocator* value);
  ::signrpc::KeyLocator* unsafe_arena_release_key_loc();

  private:
  const ::signrpc::KeyLocator& _internal_key_loc() const;
  ::signrpc::KeyLocator* _internal_mutable_key_loc();

  public:
  // bool double_hash = 3;
  void clear_double_hash() ;
  bool double_hash() const;
  void set_double_hash(bool value);

  private:
  bool _internal_double_hash() const;
  void _internal_set_double_hash(bool value);

  public:
  // bool compact_sig = 4;
  void clear_compact_sig() ;
  bool compact_sig() const;
  void set_compact_sig(bool value);

  private:
  bool _internal_compact_sig() const;
  void _internal_set_compact_sig(bool value);

  public:
  // bool schnorr_sig = 5;
  void clear_schnorr_sig() ;
  bool schnorr_sig() const;
  void set_schnorr_sig(bool value);

  private:
  bool _internal_schnorr_sig() const;
  void _internal_set_schnorr_sig(bool value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.SignMessageReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SignMessageReq_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SignMessageReq& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr msg_;
    ::google::protobuf::internal::ArenaStringPtr schnorr_sig_tap_tweak_;
    ::google::protobuf::internal::ArenaStringPtr tag_;
    ::signrpc::KeyLocator* key_loc_;
    bool double_hash_;
    bool compact_sig_;
    bool schnorr_sig_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2SessionRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2SessionRequest) */ {
 public:
  inline MuSig2SessionRequest() : MuSig2SessionRequest(nullptr) {}
  ~MuSig2SessionRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2SessionRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2SessionRequest(const MuSig2SessionRequest& from) : MuSig2SessionRequest(nullptr, from) {}
  inline MuSig2SessionRequest(MuSig2SessionRequest&& from) noexcept
      : MuSig2SessionRequest(nullptr, std::move(from)) {}
  inline MuSig2SessionRequest& operator=(const MuSig2SessionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2SessionRequest& operator=(MuSig2SessionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2SessionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2SessionRequest* internal_default_instance() {
    return reinterpret_cast<const MuSig2SessionRequest*>(
        &_MuSig2SessionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(MuSig2SessionRequest& a, MuSig2SessionRequest& b) { a.Swap(&b); }
  inline void Swap(MuSig2SessionRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2SessionRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2SessionRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2SessionRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2SessionRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2SessionRequest& from) { MuSig2SessionRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2SessionRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2SessionRequest"; }

 protected:
  explicit MuSig2SessionRequest(::google::protobuf::Arena* arena);
  MuSig2SessionRequest(::google::protobuf::Arena* arena, const MuSig2SessionRequest& from);
  MuSig2SessionRequest(::google::protobuf::Arena* arena, MuSig2SessionRequest&& from) noexcept
      : MuSig2SessionRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAllSignerPubkeysFieldNumber = 2,
    kOtherSignerPublicNoncesFieldNumber = 3,
    kTweaksFieldNumber = 4,
    kPregeneratedLocalNonceFieldNumber = 7,
    kKeyLocFieldNumber = 1,
    kTaprootTweakFieldNumber = 5,
    kVersionFieldNumber = 6,
  };
  // repeated bytes all_signer_pubkeys = 2;
  int all_signer_pubkeys_size() const;
  private:
  int _internal_all_signer_pubkeys_size() const;

  public:
  void clear_all_signer_pubkeys() ;
  const std::string& all_signer_pubkeys(int index) const;
  std::string* mutable_all_signer_pubkeys(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_all_signer_pubkeys(int index, Arg_&& value, Args_... args);
  std::string* add_all_signer_pubkeys();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_all_signer_pubkeys(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& all_signer_pubkeys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_all_signer_pubkeys();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_all_signer_pubkeys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_all_signer_pubkeys();

  public:
  // repeated bytes other_signer_public_nonces = 3;
  int other_signer_public_nonces_size() const;
  private:
  int _internal_other_signer_public_nonces_size() const;

  public:
  void clear_other_signer_public_nonces() ;
  const std::string& other_signer_public_nonces(int index) const;
  std::string* mutable_other_signer_public_nonces(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_other_signer_public_nonces(int index, Arg_&& value, Args_... args);
  std::string* add_other_signer_public_nonces();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_other_signer_public_nonces(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& other_signer_public_nonces() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_other_signer_public_nonces();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_other_signer_public_nonces() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_other_signer_public_nonces();

  public:
  // repeated .signrpc.TweakDesc tweaks = 4;
  int tweaks_size() const;
  private:
  int _internal_tweaks_size() const;

  public:
  void clear_tweaks() ;
  ::signrpc::TweakDesc* mutable_tweaks(int index);
  ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>* mutable_tweaks();

  private:
  const ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>& _internal_tweaks() const;
  ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>* _internal_mutable_tweaks();
  public:
  const ::signrpc::TweakDesc& tweaks(int index) const;
  ::signrpc::TweakDesc* add_tweaks();
  const ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>& tweaks() const;
  // bytes pregenerated_local_nonce = 7;
  void clear_pregenerated_local_nonce() ;
  const std::string& pregenerated_local_nonce() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pregenerated_local_nonce(Arg_&& arg, Args_... args);
  std::string* mutable_pregenerated_local_nonce();
  PROTOBUF_NODISCARD std::string* release_pregenerated_local_nonce();
  void set_allocated_pregenerated_local_nonce(std::string* value);

  private:
  const std::string& _internal_pregenerated_local_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pregenerated_local_nonce(
      const std::string& value);
  std::string* _internal_mutable_pregenerated_local_nonce();

  public:
  // .signrpc.KeyLocator key_loc = 1;
  bool has_key_loc() const;
  void clear_key_loc() ;
  const ::signrpc::KeyLocator& key_loc() const;
  PROTOBUF_NODISCARD ::signrpc::KeyLocator* release_key_loc();
  ::signrpc::KeyLocator* mutable_key_loc();
  void set_allocated_key_loc(::signrpc::KeyLocator* value);
  void unsafe_arena_set_allocated_key_loc(::signrpc::KeyLocator* value);
  ::signrpc::KeyLocator* unsafe_arena_release_key_loc();

  private:
  const ::signrpc::KeyLocator& _internal_key_loc() const;
  ::signrpc::KeyLocator* _internal_mutable_key_loc();

  public:
  // .signrpc.TaprootTweakDesc taproot_tweak = 5;
  bool has_taproot_tweak() const;
  void clear_taproot_tweak() ;
  const ::signrpc::TaprootTweakDesc& taproot_tweak() const;
  PROTOBUF_NODISCARD ::signrpc::TaprootTweakDesc* release_taproot_tweak();
  ::signrpc::TaprootTweakDesc* mutable_taproot_tweak();
  void set_allocated_taproot_tweak(::signrpc::TaprootTweakDesc* value);
  void unsafe_arena_set_allocated_taproot_tweak(::signrpc::TaprootTweakDesc* value);
  ::signrpc::TaprootTweakDesc* unsafe_arena_release_taproot_tweak();

  private:
  const ::signrpc::TaprootTweakDesc& _internal_taproot_tweak() const;
  ::signrpc::TaprootTweakDesc* _internal_mutable_taproot_tweak();

  public:
  // .signrpc.MuSig2Version version = 6;
  void clear_version() ;
  ::signrpc::MuSig2Version version() const;
  void set_version(::signrpc::MuSig2Version value);

  private:
  ::signrpc::MuSig2Version _internal_version() const;
  void _internal_set_version(::signrpc::MuSig2Version value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2SessionRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 7, 3,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2SessionRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2SessionRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> all_signer_pubkeys_;
    ::google::protobuf::RepeatedPtrField<std::string> other_signer_public_nonces_;
    ::google::protobuf::RepeatedPtrField< ::signrpc::TweakDesc > tweaks_;
    ::google::protobuf::internal::ArenaStringPtr pregenerated_local_nonce_;
    ::signrpc::KeyLocator* key_loc_;
    ::signrpc::TaprootTweakDesc* taproot_tweak_;
    int version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class MuSig2CombineKeysRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.MuSig2CombineKeysRequest) */ {
 public:
  inline MuSig2CombineKeysRequest() : MuSig2CombineKeysRequest(nullptr) {}
  ~MuSig2CombineKeysRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR MuSig2CombineKeysRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline MuSig2CombineKeysRequest(const MuSig2CombineKeysRequest& from) : MuSig2CombineKeysRequest(nullptr, from) {}
  inline MuSig2CombineKeysRequest(MuSig2CombineKeysRequest&& from) noexcept
      : MuSig2CombineKeysRequest(nullptr, std::move(from)) {}
  inline MuSig2CombineKeysRequest& operator=(const MuSig2CombineKeysRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MuSig2CombineKeysRequest& operator=(MuSig2CombineKeysRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MuSig2CombineKeysRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MuSig2CombineKeysRequest* internal_default_instance() {
    return reinterpret_cast<const MuSig2CombineKeysRequest*>(
        &_MuSig2CombineKeysRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(MuSig2CombineKeysRequest& a, MuSig2CombineKeysRequest& b) { a.Swap(&b); }
  inline void Swap(MuSig2CombineKeysRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MuSig2CombineKeysRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MuSig2CombineKeysRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<MuSig2CombineKeysRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const MuSig2CombineKeysRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const MuSig2CombineKeysRequest& from) { MuSig2CombineKeysRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(MuSig2CombineKeysRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.MuSig2CombineKeysRequest"; }

 protected:
  explicit MuSig2CombineKeysRequest(::google::protobuf::Arena* arena);
  MuSig2CombineKeysRequest(::google::protobuf::Arena* arena, const MuSig2CombineKeysRequest& from);
  MuSig2CombineKeysRequest(::google::protobuf::Arena* arena, MuSig2CombineKeysRequest&& from) noexcept
      : MuSig2CombineKeysRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAllSignerPubkeysFieldNumber = 1,
    kTweaksFieldNumber = 2,
    kTaprootTweakFieldNumber = 3,
    kVersionFieldNumber = 4,
  };
  // repeated bytes all_signer_pubkeys = 1;
  int all_signer_pubkeys_size() const;
  private:
  int _internal_all_signer_pubkeys_size() const;

  public:
  void clear_all_signer_pubkeys() ;
  const std::string& all_signer_pubkeys(int index) const;
  std::string* mutable_all_signer_pubkeys(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_all_signer_pubkeys(int index, Arg_&& value, Args_... args);
  std::string* add_all_signer_pubkeys();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_all_signer_pubkeys(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& all_signer_pubkeys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_all_signer_pubkeys();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_all_signer_pubkeys() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_all_signer_pubkeys();

  public:
  // repeated .signrpc.TweakDesc tweaks = 2;
  int tweaks_size() const;
  private:
  int _internal_tweaks_size() const;

  public:
  void clear_tweaks() ;
  ::signrpc::TweakDesc* mutable_tweaks(int index);
  ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>* mutable_tweaks();

  private:
  const ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>& _internal_tweaks() const;
  ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>* _internal_mutable_tweaks();
  public:
  const ::signrpc::TweakDesc& tweaks(int index) const;
  ::signrpc::TweakDesc* add_tweaks();
  const ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>& tweaks() const;
  // .signrpc.TaprootTweakDesc taproot_tweak = 3;
  bool has_taproot_tweak() const;
  void clear_taproot_tweak() ;
  const ::signrpc::TaprootTweakDesc& taproot_tweak() const;
  PROTOBUF_NODISCARD ::signrpc::TaprootTweakDesc* release_taproot_tweak();
  ::signrpc::TaprootTweakDesc* mutable_taproot_tweak();
  void set_allocated_taproot_tweak(::signrpc::TaprootTweakDesc* value);
  void unsafe_arena_set_allocated_taproot_tweak(::signrpc::TaprootTweakDesc* value);
  ::signrpc::TaprootTweakDesc* unsafe_arena_release_taproot_tweak();

  private:
  const ::signrpc::TaprootTweakDesc& _internal_taproot_tweak() const;
  ::signrpc::TaprootTweakDesc* _internal_mutable_taproot_tweak();

  public:
  // .signrpc.MuSig2Version version = 4;
  void clear_version() ;
  ::signrpc::MuSig2Version version() const;
  void set_version(::signrpc::MuSig2Version value);

  private:
  ::signrpc::MuSig2Version _internal_version() const;
  void _internal_set_version(::signrpc::MuSig2Version value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.MuSig2CombineKeysRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_MuSig2CombineKeysRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const MuSig2CombineKeysRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> all_signer_pubkeys_;
    ::google::protobuf::RepeatedPtrField< ::signrpc::TweakDesc > tweaks_;
    ::signrpc::TaprootTweakDesc* taproot_tweak_;
    int version_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class KeyDescriptor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.KeyDescriptor) */ {
 public:
  inline KeyDescriptor() : KeyDescriptor(nullptr) {}
  ~KeyDescriptor() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR KeyDescriptor(
      ::google::protobuf::internal::ConstantInitialized);

  inline KeyDescriptor(const KeyDescriptor& from) : KeyDescriptor(nullptr, from) {}
  inline KeyDescriptor(KeyDescriptor&& from) noexcept
      : KeyDescriptor(nullptr, std::move(from)) {}
  inline KeyDescriptor& operator=(const KeyDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyDescriptor& operator=(KeyDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyDescriptor* internal_default_instance() {
    return reinterpret_cast<const KeyDescriptor*>(
        &_KeyDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(KeyDescriptor& a, KeyDescriptor& b) { a.Swap(&b); }
  inline void Swap(KeyDescriptor* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyDescriptor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyDescriptor* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<KeyDescriptor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const KeyDescriptor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const KeyDescriptor& from) { KeyDescriptor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(KeyDescriptor* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.KeyDescriptor"; }

 protected:
  explicit KeyDescriptor(::google::protobuf::Arena* arena);
  KeyDescriptor(::google::protobuf::Arena* arena, const KeyDescriptor& from);
  KeyDescriptor(::google::protobuf::Arena* arena, KeyDescriptor&& from) noexcept
      : KeyDescriptor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRawKeyBytesFieldNumber = 1,
    kKeyLocFieldNumber = 2,
  };
  // bytes raw_key_bytes = 1;
  void clear_raw_key_bytes() ;
  const std::string& raw_key_bytes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_key_bytes(Arg_&& arg, Args_... args);
  std::string* mutable_raw_key_bytes();
  PROTOBUF_NODISCARD std::string* release_raw_key_bytes();
  void set_allocated_raw_key_bytes(std::string* value);

  private:
  const std::string& _internal_raw_key_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_key_bytes(
      const std::string& value);
  std::string* _internal_mutable_raw_key_bytes();

  public:
  // .signrpc.KeyLocator key_loc = 2;
  bool has_key_loc() const;
  void clear_key_loc() ;
  const ::signrpc::KeyLocator& key_loc() const;
  PROTOBUF_NODISCARD ::signrpc::KeyLocator* release_key_loc();
  ::signrpc::KeyLocator* mutable_key_loc();
  void set_allocated_key_loc(::signrpc::KeyLocator* value);
  void unsafe_arena_set_allocated_key_loc(::signrpc::KeyLocator* value);
  ::signrpc::KeyLocator* unsafe_arena_release_key_loc();

  private:
  const ::signrpc::KeyLocator& _internal_key_loc() const;
  ::signrpc::KeyLocator* _internal_mutable_key_loc();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.KeyDescriptor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_KeyDescriptor_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const KeyDescriptor& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr raw_key_bytes_;
    ::signrpc::KeyLocator* key_loc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class InputScriptResp final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.InputScriptResp) */ {
 public:
  inline InputScriptResp() : InputScriptResp(nullptr) {}
  ~InputScriptResp() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR InputScriptResp(
      ::google::protobuf::internal::ConstantInitialized);

  inline InputScriptResp(const InputScriptResp& from) : InputScriptResp(nullptr, from) {}
  inline InputScriptResp(InputScriptResp&& from) noexcept
      : InputScriptResp(nullptr, std::move(from)) {}
  inline InputScriptResp& operator=(const InputScriptResp& from) {
    CopyFrom(from);
    return *this;
  }
  inline InputScriptResp& operator=(InputScriptResp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InputScriptResp& default_instance() {
    return *internal_default_instance();
  }
  static inline const InputScriptResp* internal_default_instance() {
    return reinterpret_cast<const InputScriptResp*>(
        &_InputScriptResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(InputScriptResp& a, InputScriptResp& b) { a.Swap(&b); }
  inline void Swap(InputScriptResp* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InputScriptResp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InputScriptResp* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<InputScriptResp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const InputScriptResp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const InputScriptResp& from) { InputScriptResp::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(InputScriptResp* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.InputScriptResp"; }

 protected:
  explicit InputScriptResp(::google::protobuf::Arena* arena);
  InputScriptResp(::google::protobuf::Arena* arena, const InputScriptResp& from);
  InputScriptResp(::google::protobuf::Arena* arena, InputScriptResp&& from) noexcept
      : InputScriptResp(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kInputScriptsFieldNumber = 1,
  };
  // repeated .signrpc.InputScript input_scripts = 1;
  int input_scripts_size() const;
  private:
  int _internal_input_scripts_size() const;

  public:
  void clear_input_scripts() ;
  ::signrpc::InputScript* mutable_input_scripts(int index);
  ::google::protobuf::RepeatedPtrField<::signrpc::InputScript>* mutable_input_scripts();

  private:
  const ::google::protobuf::RepeatedPtrField<::signrpc::InputScript>& _internal_input_scripts() const;
  ::google::protobuf::RepeatedPtrField<::signrpc::InputScript>* _internal_mutable_input_scripts();
  public:
  const ::signrpc::InputScript& input_scripts(int index) const;
  ::signrpc::InputScript* add_input_scripts();
  const ::google::protobuf::RepeatedPtrField<::signrpc::InputScript>& input_scripts() const;
  // @@protoc_insertion_point(class_scope:signrpc.InputScriptResp)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_InputScriptResp_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const InputScriptResp& from_msg);
    ::google::protobuf::RepeatedPtrField< ::signrpc::InputScript > input_scripts_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class SignDescriptor final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.SignDescriptor) */ {
 public:
  inline SignDescriptor() : SignDescriptor(nullptr) {}
  ~SignDescriptor() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignDescriptor(
      ::google::protobuf::internal::ConstantInitialized);

  inline SignDescriptor(const SignDescriptor& from) : SignDescriptor(nullptr, from) {}
  inline SignDescriptor(SignDescriptor&& from) noexcept
      : SignDescriptor(nullptr, std::move(from)) {}
  inline SignDescriptor& operator=(const SignDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignDescriptor& operator=(SignDescriptor&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignDescriptor& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignDescriptor* internal_default_instance() {
    return reinterpret_cast<const SignDescriptor*>(
        &_SignDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(SignDescriptor& a, SignDescriptor& b) { a.Swap(&b); }
  inline void Swap(SignDescriptor* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignDescriptor* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignDescriptor* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SignDescriptor>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignDescriptor& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SignDescriptor& from) { SignDescriptor::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SignDescriptor* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.SignDescriptor"; }

 protected:
  explicit SignDescriptor(::google::protobuf::Arena* arena);
  SignDescriptor(::google::protobuf::Arena* arena, const SignDescriptor& from);
  SignDescriptor(::google::protobuf::Arena* arena, SignDescriptor&& from) noexcept
      : SignDescriptor(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSingleTweakFieldNumber = 2,
    kDoubleTweakFieldNumber = 3,
    kWitnessScriptFieldNumber = 4,
    kTapTweakFieldNumber = 10,
    kKeyDescFieldNumber = 1,
    kOutputFieldNumber = 5,
    kSighashFieldNumber = 7,
    kInputIndexFieldNumber = 8,
    kSignMethodFieldNumber = 9,
  };
  // bytes single_tweak = 2;
  void clear_single_tweak() ;
  const std::string& single_tweak() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_single_tweak(Arg_&& arg, Args_... args);
  std::string* mutable_single_tweak();
  PROTOBUF_NODISCARD std::string* release_single_tweak();
  void set_allocated_single_tweak(std::string* value);

  private:
  const std::string& _internal_single_tweak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_single_tweak(
      const std::string& value);
  std::string* _internal_mutable_single_tweak();

  public:
  // bytes double_tweak = 3;
  void clear_double_tweak() ;
  const std::string& double_tweak() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_double_tweak(Arg_&& arg, Args_... args);
  std::string* mutable_double_tweak();
  PROTOBUF_NODISCARD std::string* release_double_tweak();
  void set_allocated_double_tweak(std::string* value);

  private:
  const std::string& _internal_double_tweak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_double_tweak(
      const std::string& value);
  std::string* _internal_mutable_double_tweak();

  public:
  // bytes witness_script = 4;
  void clear_witness_script() ;
  const std::string& witness_script() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_witness_script(Arg_&& arg, Args_... args);
  std::string* mutable_witness_script();
  PROTOBUF_NODISCARD std::string* release_witness_script();
  void set_allocated_witness_script(std::string* value);

  private:
  const std::string& _internal_witness_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_witness_script(
      const std::string& value);
  std::string* _internal_mutable_witness_script();

  public:
  // bytes tap_tweak = 10;
  void clear_tap_tweak() ;
  const std::string& tap_tweak() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tap_tweak(Arg_&& arg, Args_... args);
  std::string* mutable_tap_tweak();
  PROTOBUF_NODISCARD std::string* release_tap_tweak();
  void set_allocated_tap_tweak(std::string* value);

  private:
  const std::string& _internal_tap_tweak() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tap_tweak(
      const std::string& value);
  std::string* _internal_mutable_tap_tweak();

  public:
  // .signrpc.KeyDescriptor key_desc = 1;
  bool has_key_desc() const;
  void clear_key_desc() ;
  const ::signrpc::KeyDescriptor& key_desc() const;
  PROTOBUF_NODISCARD ::signrpc::KeyDescriptor* release_key_desc();
  ::signrpc::KeyDescriptor* mutable_key_desc();
  void set_allocated_key_desc(::signrpc::KeyDescriptor* value);
  void unsafe_arena_set_allocated_key_desc(::signrpc::KeyDescriptor* value);
  ::signrpc::KeyDescriptor* unsafe_arena_release_key_desc();

  private:
  const ::signrpc::KeyDescriptor& _internal_key_desc() const;
  ::signrpc::KeyDescriptor* _internal_mutable_key_desc();

  public:
  // .signrpc.TxOut output = 5;
  bool has_output() const;
  void clear_output() ;
  const ::signrpc::TxOut& output() const;
  PROTOBUF_NODISCARD ::signrpc::TxOut* release_output();
  ::signrpc::TxOut* mutable_output();
  void set_allocated_output(::signrpc::TxOut* value);
  void unsafe_arena_set_allocated_output(::signrpc::TxOut* value);
  ::signrpc::TxOut* unsafe_arena_release_output();

  private:
  const ::signrpc::TxOut& _internal_output() const;
  ::signrpc::TxOut* _internal_mutable_output();

  public:
  // uint32 sighash = 7;
  void clear_sighash() ;
  ::uint32_t sighash() const;
  void set_sighash(::uint32_t value);

  private:
  ::uint32_t _internal_sighash() const;
  void _internal_set_sighash(::uint32_t value);

  public:
  // int32 input_index = 8;
  void clear_input_index() ;
  ::int32_t input_index() const;
  void set_input_index(::int32_t value);

  private:
  ::int32_t _internal_input_index() const;
  void _internal_set_input_index(::int32_t value);

  public:
  // .signrpc.SignMethod sign_method = 9;
  void clear_sign_method() ;
  ::signrpc::SignMethod sign_method() const;
  void set_sign_method(::signrpc::SignMethod value);

  private:
  ::signrpc::SignMethod _internal_sign_method() const;
  void _internal_set_sign_method(::signrpc::SignMethod value);

  public:
  // @@protoc_insertion_point(class_scope:signrpc.SignDescriptor)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SignDescriptor_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SignDescriptor& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr single_tweak_;
    ::google::protobuf::internal::ArenaStringPtr double_tweak_;
    ::google::protobuf::internal::ArenaStringPtr witness_script_;
    ::google::protobuf::internal::ArenaStringPtr tap_tweak_;
    ::signrpc::KeyDescriptor* key_desc_;
    ::signrpc::TxOut* output_;
    ::uint32_t sighash_;
    ::int32_t input_index_;
    int sign_method_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class SharedKeyRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.SharedKeyRequest) */ {
 public:
  inline SharedKeyRequest() : SharedKeyRequest(nullptr) {}
  ~SharedKeyRequest() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SharedKeyRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SharedKeyRequest(const SharedKeyRequest& from) : SharedKeyRequest(nullptr, from) {}
  inline SharedKeyRequest(SharedKeyRequest&& from) noexcept
      : SharedKeyRequest(nullptr, std::move(from)) {}
  inline SharedKeyRequest& operator=(const SharedKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SharedKeyRequest& operator=(SharedKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SharedKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SharedKeyRequest* internal_default_instance() {
    return reinterpret_cast<const SharedKeyRequest*>(
        &_SharedKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SharedKeyRequest& a, SharedKeyRequest& b) { a.Swap(&b); }
  inline void Swap(SharedKeyRequest* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SharedKeyRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SharedKeyRequest* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SharedKeyRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SharedKeyRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SharedKeyRequest& from) { SharedKeyRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SharedKeyRequest* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.SharedKeyRequest"; }

 protected:
  explicit SharedKeyRequest(::google::protobuf::Arena* arena);
  SharedKeyRequest(::google::protobuf::Arena* arena, const SharedKeyRequest& from);
  SharedKeyRequest(::google::protobuf::Arena* arena, SharedKeyRequest&& from) noexcept
      : SharedKeyRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kEphemeralPubkeyFieldNumber = 1,
    kKeyLocFieldNumber = 2,
    kKeyDescFieldNumber = 3,
  };
  // bytes ephemeral_pubkey = 1;
  void clear_ephemeral_pubkey() ;
  const std::string& ephemeral_pubkey() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_ephemeral_pubkey(Arg_&& arg, Args_... args);
  std::string* mutable_ephemeral_pubkey();
  PROTOBUF_NODISCARD std::string* release_ephemeral_pubkey();
  void set_allocated_ephemeral_pubkey(std::string* value);

  private:
  const std::string& _internal_ephemeral_pubkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ephemeral_pubkey(
      const std::string& value);
  std::string* _internal_mutable_ephemeral_pubkey();

  public:
  // .signrpc.KeyLocator key_loc = 2 [deprecated = true];
  [[deprecated]]  bool has_key_loc() const;
  [[deprecated]]  void clear_key_loc() ;
  [[deprecated]] const ::signrpc::KeyLocator& key_loc() const;
  [[deprecated]] PROTOBUF_NODISCARD ::signrpc::KeyLocator* release_key_loc();
  [[deprecated]] ::signrpc::KeyLocator* mutable_key_loc();
  [[deprecated]] void set_allocated_key_loc(::signrpc::KeyLocator* value);
  [[deprecated]] void unsafe_arena_set_allocated_key_loc(::signrpc::KeyLocator* value);
  [[deprecated]] ::signrpc::KeyLocator* unsafe_arena_release_key_loc();

  private:
  const ::signrpc::KeyLocator& _internal_key_loc() const;
  ::signrpc::KeyLocator* _internal_mutable_key_loc();

  public:
  // .signrpc.KeyDescriptor key_desc = 3;
  bool has_key_desc() const;
  void clear_key_desc() ;
  const ::signrpc::KeyDescriptor& key_desc() const;
  PROTOBUF_NODISCARD ::signrpc::KeyDescriptor* release_key_desc();
  ::signrpc::KeyDescriptor* mutable_key_desc();
  void set_allocated_key_desc(::signrpc::KeyDescriptor* value);
  void unsafe_arena_set_allocated_key_desc(::signrpc::KeyDescriptor* value);
  ::signrpc::KeyDescriptor* unsafe_arena_release_key_desc();

  private:
  const ::signrpc::KeyDescriptor& _internal_key_desc() const;
  ::signrpc::KeyDescriptor* _internal_mutable_key_desc();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.SharedKeyRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SharedKeyRequest_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SharedKeyRequest& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr ephemeral_pubkey_;
    ::signrpc::KeyLocator* key_loc_;
    ::signrpc::KeyDescriptor* key_desc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};
// -------------------------------------------------------------------

class SignReq final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:signrpc.SignReq) */ {
 public:
  inline SignReq() : SignReq(nullptr) {}
  ~SignReq() PROTOBUF_FINAL;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SignReq(
      ::google::protobuf::internal::ConstantInitialized);

  inline SignReq(const SignReq& from) : SignReq(nullptr, from) {}
  inline SignReq(SignReq&& from) noexcept
      : SignReq(nullptr, std::move(from)) {}
  inline SignReq& operator=(const SignReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignReq& operator=(SignReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignReq* internal_default_instance() {
    return reinterpret_cast<const SignReq*>(
        &_SignReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SignReq& a, SignReq& b) { a.Swap(&b); }
  inline void Swap(SignReq* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignReq* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignReq* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL {
    return ::google::protobuf::Message::DefaultConstruct<SignReq>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SignReq& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SignReq& from) { SignReq::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SignReq* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "signrpc.SignReq"; }

 protected:
  explicit SignReq(::google::protobuf::Arena* arena);
  SignReq(::google::protobuf::Arena* arena, const SignReq& from);
  SignReq(::google::protobuf::Arena* arena, SignReq&& from) noexcept
      : SignReq(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::Message::ClassData* GetClassData() const PROTOBUF_FINAL;
  static const ::google::protobuf::Message::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSignDescsFieldNumber = 2,
    kPrevOutputsFieldNumber = 3,
    kRawTxBytesFieldNumber = 1,
  };
  // repeated .signrpc.SignDescriptor sign_descs = 2;
  int sign_descs_size() const;
  private:
  int _internal_sign_descs_size() const;

  public:
  void clear_sign_descs() ;
  ::signrpc::SignDescriptor* mutable_sign_descs(int index);
  ::google::protobuf::RepeatedPtrField<::signrpc::SignDescriptor>* mutable_sign_descs();

  private:
  const ::google::protobuf::RepeatedPtrField<::signrpc::SignDescriptor>& _internal_sign_descs() const;
  ::google::protobuf::RepeatedPtrField<::signrpc::SignDescriptor>* _internal_mutable_sign_descs();
  public:
  const ::signrpc::SignDescriptor& sign_descs(int index) const;
  ::signrpc::SignDescriptor* add_sign_descs();
  const ::google::protobuf::RepeatedPtrField<::signrpc::SignDescriptor>& sign_descs() const;
  // repeated .signrpc.TxOut prev_outputs = 3;
  int prev_outputs_size() const;
  private:
  int _internal_prev_outputs_size() const;

  public:
  void clear_prev_outputs() ;
  ::signrpc::TxOut* mutable_prev_outputs(int index);
  ::google::protobuf::RepeatedPtrField<::signrpc::TxOut>* mutable_prev_outputs();

  private:
  const ::google::protobuf::RepeatedPtrField<::signrpc::TxOut>& _internal_prev_outputs() const;
  ::google::protobuf::RepeatedPtrField<::signrpc::TxOut>* _internal_mutable_prev_outputs();
  public:
  const ::signrpc::TxOut& prev_outputs(int index) const;
  ::signrpc::TxOut* add_prev_outputs();
  const ::google::protobuf::RepeatedPtrField<::signrpc::TxOut>& prev_outputs() const;
  // bytes raw_tx_bytes = 1;
  void clear_raw_tx_bytes() ;
  const std::string& raw_tx_bytes() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_raw_tx_bytes(Arg_&& arg, Args_... args);
  std::string* mutable_raw_tx_bytes();
  PROTOBUF_NODISCARD std::string* release_raw_tx_bytes();
  void set_allocated_raw_tx_bytes(std::string* value);

  private:
  const std::string& _internal_raw_tx_bytes() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_tx_bytes(
      const std::string& value);
  std::string* _internal_mutable_raw_tx_bytes();

  public:
  // @@protoc_insertion_point(class_scope:signrpc.SignReq)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;

  static constexpr const void* _raw_default_instance_ =
      &_SignReq_default_instance_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SignReq& from_msg);
    ::google::protobuf::RepeatedPtrField< ::signrpc::SignDescriptor > sign_descs_;
    ::google::protobuf::RepeatedPtrField< ::signrpc::TxOut > prev_outputs_;
    ::google::protobuf::internal::ArenaStringPtr raw_tx_bytes_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_signer_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// KeyLocator

// int32 key_family = 1;
inline void KeyLocator::clear_key_family() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_family_ = 0;
}
inline ::int32_t KeyLocator::key_family() const {
  // @@protoc_insertion_point(field_get:signrpc.KeyLocator.key_family)
  return _internal_key_family();
}
inline void KeyLocator::set_key_family(::int32_t value) {
  _internal_set_key_family(value);
  // @@protoc_insertion_point(field_set:signrpc.KeyLocator.key_family)
}
inline ::int32_t KeyLocator::_internal_key_family() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_family_;
}
inline void KeyLocator::_internal_set_key_family(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_family_ = value;
}

// int32 key_index = 2;
inline void KeyLocator::clear_key_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_index_ = 0;
}
inline ::int32_t KeyLocator::key_index() const {
  // @@protoc_insertion_point(field_get:signrpc.KeyLocator.key_index)
  return _internal_key_index();
}
inline void KeyLocator::set_key_index(::int32_t value) {
  _internal_set_key_index(value);
  // @@protoc_insertion_point(field_set:signrpc.KeyLocator.key_index)
}
inline ::int32_t KeyLocator::_internal_key_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_index_;
}
inline void KeyLocator::_internal_set_key_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_index_ = value;
}

// -------------------------------------------------------------------

// KeyDescriptor

// bytes raw_key_bytes = 1;
inline void KeyDescriptor::clear_raw_key_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.raw_key_bytes_.ClearToEmpty();
}
inline const std::string& KeyDescriptor::raw_key_bytes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.KeyDescriptor.raw_key_bytes)
  return _internal_raw_key_bytes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void KeyDescriptor::set_raw_key_bytes(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.raw_key_bytes_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.KeyDescriptor.raw_key_bytes)
}
inline std::string* KeyDescriptor::mutable_raw_key_bytes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_raw_key_bytes();
  // @@protoc_insertion_point(field_mutable:signrpc.KeyDescriptor.raw_key_bytes)
  return _s;
}
inline const std::string& KeyDescriptor::_internal_raw_key_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.raw_key_bytes_.Get();
}
inline void KeyDescriptor::_internal_set_raw_key_bytes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.raw_key_bytes_.Set(value, GetArena());
}
inline std::string* KeyDescriptor::_internal_mutable_raw_key_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.raw_key_bytes_.Mutable( GetArena());
}
inline std::string* KeyDescriptor::release_raw_key_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.KeyDescriptor.raw_key_bytes)
  return _impl_.raw_key_bytes_.Release();
}
inline void KeyDescriptor::set_allocated_raw_key_bytes(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.raw_key_bytes_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.raw_key_bytes_.IsDefault()) {
          _impl_.raw_key_bytes_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.KeyDescriptor.raw_key_bytes)
}

// .signrpc.KeyLocator key_loc = 2;
inline bool KeyDescriptor::has_key_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_loc_ != nullptr);
  return value;
}
inline void KeyDescriptor::clear_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_loc_ != nullptr) _impl_.key_loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::signrpc::KeyLocator& KeyDescriptor::_internal_key_loc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::signrpc::KeyLocator* p = _impl_.key_loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::signrpc::KeyLocator&>(::signrpc::_KeyLocator_default_instance_);
}
inline const ::signrpc::KeyLocator& KeyDescriptor::key_loc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.KeyDescriptor.key_loc)
  return _internal_key_loc();
}
inline void KeyDescriptor::unsafe_arena_set_allocated_key_loc(::signrpc::KeyLocator* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_loc_);
  }
  _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signrpc.KeyDescriptor.key_loc)
}
inline ::signrpc::KeyLocator* KeyDescriptor::release_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::KeyLocator* released = _impl_.key_loc_;
  _impl_.key_loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::signrpc::KeyLocator* KeyDescriptor::unsafe_arena_release_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.KeyDescriptor.key_loc)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::KeyLocator* temp = _impl_.key_loc_;
  _impl_.key_loc_ = nullptr;
  return temp;
}
inline ::signrpc::KeyLocator* KeyDescriptor::_internal_mutable_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_loc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::signrpc::KeyLocator>(GetArena());
    _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(p);
  }
  return _impl_.key_loc_;
}
inline ::signrpc::KeyLocator* KeyDescriptor::mutable_key_loc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::signrpc::KeyLocator* _msg = _internal_mutable_key_loc();
  // @@protoc_insertion_point(field_mutable:signrpc.KeyDescriptor.key_loc)
  return _msg;
}
inline void KeyDescriptor::set_allocated_key_loc(::signrpc::KeyLocator* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.key_loc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(value);
  // @@protoc_insertion_point(field_set_allocated:signrpc.KeyDescriptor.key_loc)
}

// -------------------------------------------------------------------

// TxOut

// int64 value = 1;
inline void TxOut::clear_value() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = ::int64_t{0};
}
inline ::int64_t TxOut::value() const {
  // @@protoc_insertion_point(field_get:signrpc.TxOut.value)
  return _internal_value();
}
inline void TxOut::set_value(::int64_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:signrpc.TxOut.value)
}
inline ::int64_t TxOut::_internal_value() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.value_;
}
inline void TxOut::_internal_set_value(::int64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.value_ = value;
}

// bytes pk_script = 2;
inline void TxOut::clear_pk_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pk_script_.ClearToEmpty();
}
inline const std::string& TxOut::pk_script() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.TxOut.pk_script)
  return _internal_pk_script();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TxOut::set_pk_script(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pk_script_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.TxOut.pk_script)
}
inline std::string* TxOut::mutable_pk_script() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pk_script();
  // @@protoc_insertion_point(field_mutable:signrpc.TxOut.pk_script)
  return _s;
}
inline const std::string& TxOut::_internal_pk_script() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pk_script_.Get();
}
inline void TxOut::_internal_set_pk_script(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pk_script_.Set(value, GetArena());
}
inline std::string* TxOut::_internal_mutable_pk_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pk_script_.Mutable( GetArena());
}
inline std::string* TxOut::release_pk_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.TxOut.pk_script)
  return _impl_.pk_script_.Release();
}
inline void TxOut::set_allocated_pk_script(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pk_script_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pk_script_.IsDefault()) {
          _impl_.pk_script_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.TxOut.pk_script)
}

// -------------------------------------------------------------------

// SignDescriptor

// .signrpc.KeyDescriptor key_desc = 1;
inline bool SignDescriptor::has_key_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_desc_ != nullptr);
  return value;
}
inline void SignDescriptor::clear_key_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_desc_ != nullptr) _impl_.key_desc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::signrpc::KeyDescriptor& SignDescriptor::_internal_key_desc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::signrpc::KeyDescriptor* p = _impl_.key_desc_;
  return p != nullptr ? *p : reinterpret_cast<const ::signrpc::KeyDescriptor&>(::signrpc::_KeyDescriptor_default_instance_);
}
inline const ::signrpc::KeyDescriptor& SignDescriptor::key_desc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignDescriptor.key_desc)
  return _internal_key_desc();
}
inline void SignDescriptor::unsafe_arena_set_allocated_key_desc(::signrpc::KeyDescriptor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_desc_);
  }
  _impl_.key_desc_ = reinterpret_cast<::signrpc::KeyDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signrpc.SignDescriptor.key_desc)
}
inline ::signrpc::KeyDescriptor* SignDescriptor::release_key_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::KeyDescriptor* released = _impl_.key_desc_;
  _impl_.key_desc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::signrpc::KeyDescriptor* SignDescriptor::unsafe_arena_release_key_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignDescriptor.key_desc)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::KeyDescriptor* temp = _impl_.key_desc_;
  _impl_.key_desc_ = nullptr;
  return temp;
}
inline ::signrpc::KeyDescriptor* SignDescriptor::_internal_mutable_key_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_desc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::signrpc::KeyDescriptor>(GetArena());
    _impl_.key_desc_ = reinterpret_cast<::signrpc::KeyDescriptor*>(p);
  }
  return _impl_.key_desc_;
}
inline ::signrpc::KeyDescriptor* SignDescriptor::mutable_key_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::signrpc::KeyDescriptor* _msg = _internal_mutable_key_desc();
  // @@protoc_insertion_point(field_mutable:signrpc.SignDescriptor.key_desc)
  return _msg;
}
inline void SignDescriptor::set_allocated_key_desc(::signrpc::KeyDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.key_desc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.key_desc_ = reinterpret_cast<::signrpc::KeyDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignDescriptor.key_desc)
}

// bytes single_tweak = 2;
inline void SignDescriptor::clear_single_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.single_tweak_.ClearToEmpty();
}
inline const std::string& SignDescriptor::single_tweak() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignDescriptor.single_tweak)
  return _internal_single_tweak();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignDescriptor::set_single_tweak(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.single_tweak_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SignDescriptor.single_tweak)
}
inline std::string* SignDescriptor::mutable_single_tweak() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_single_tweak();
  // @@protoc_insertion_point(field_mutable:signrpc.SignDescriptor.single_tweak)
  return _s;
}
inline const std::string& SignDescriptor::_internal_single_tweak() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.single_tweak_.Get();
}
inline void SignDescriptor::_internal_set_single_tweak(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.single_tweak_.Set(value, GetArena());
}
inline std::string* SignDescriptor::_internal_mutable_single_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.single_tweak_.Mutable( GetArena());
}
inline std::string* SignDescriptor::release_single_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignDescriptor.single_tweak)
  return _impl_.single_tweak_.Release();
}
inline void SignDescriptor::set_allocated_single_tweak(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.single_tweak_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.single_tweak_.IsDefault()) {
          _impl_.single_tweak_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignDescriptor.single_tweak)
}

// bytes double_tweak = 3;
inline void SignDescriptor::clear_double_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.double_tweak_.ClearToEmpty();
}
inline const std::string& SignDescriptor::double_tweak() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignDescriptor.double_tweak)
  return _internal_double_tweak();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignDescriptor::set_double_tweak(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.double_tweak_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SignDescriptor.double_tweak)
}
inline std::string* SignDescriptor::mutable_double_tweak() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_double_tweak();
  // @@protoc_insertion_point(field_mutable:signrpc.SignDescriptor.double_tweak)
  return _s;
}
inline const std::string& SignDescriptor::_internal_double_tweak() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.double_tweak_.Get();
}
inline void SignDescriptor::_internal_set_double_tweak(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.double_tweak_.Set(value, GetArena());
}
inline std::string* SignDescriptor::_internal_mutable_double_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.double_tweak_.Mutable( GetArena());
}
inline std::string* SignDescriptor::release_double_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignDescriptor.double_tweak)
  return _impl_.double_tweak_.Release();
}
inline void SignDescriptor::set_allocated_double_tweak(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.double_tweak_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.double_tweak_.IsDefault()) {
          _impl_.double_tweak_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignDescriptor.double_tweak)
}

// bytes tap_tweak = 10;
inline void SignDescriptor::clear_tap_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tap_tweak_.ClearToEmpty();
}
inline const std::string& SignDescriptor::tap_tweak() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignDescriptor.tap_tweak)
  return _internal_tap_tweak();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignDescriptor::set_tap_tweak(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tap_tweak_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SignDescriptor.tap_tweak)
}
inline std::string* SignDescriptor::mutable_tap_tweak() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tap_tweak();
  // @@protoc_insertion_point(field_mutable:signrpc.SignDescriptor.tap_tweak)
  return _s;
}
inline const std::string& SignDescriptor::_internal_tap_tweak() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tap_tweak_.Get();
}
inline void SignDescriptor::_internal_set_tap_tweak(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tap_tweak_.Set(value, GetArena());
}
inline std::string* SignDescriptor::_internal_mutable_tap_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tap_tweak_.Mutable( GetArena());
}
inline std::string* SignDescriptor::release_tap_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignDescriptor.tap_tweak)
  return _impl_.tap_tweak_.Release();
}
inline void SignDescriptor::set_allocated_tap_tweak(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tap_tweak_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tap_tweak_.IsDefault()) {
          _impl_.tap_tweak_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignDescriptor.tap_tweak)
}

// bytes witness_script = 4;
inline void SignDescriptor::clear_witness_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.witness_script_.ClearToEmpty();
}
inline const std::string& SignDescriptor::witness_script() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignDescriptor.witness_script)
  return _internal_witness_script();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignDescriptor::set_witness_script(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.witness_script_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SignDescriptor.witness_script)
}
inline std::string* SignDescriptor::mutable_witness_script() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_witness_script();
  // @@protoc_insertion_point(field_mutable:signrpc.SignDescriptor.witness_script)
  return _s;
}
inline const std::string& SignDescriptor::_internal_witness_script() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.witness_script_.Get();
}
inline void SignDescriptor::_internal_set_witness_script(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.witness_script_.Set(value, GetArena());
}
inline std::string* SignDescriptor::_internal_mutable_witness_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.witness_script_.Mutable( GetArena());
}
inline std::string* SignDescriptor::release_witness_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignDescriptor.witness_script)
  return _impl_.witness_script_.Release();
}
inline void SignDescriptor::set_allocated_witness_script(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.witness_script_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.witness_script_.IsDefault()) {
          _impl_.witness_script_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignDescriptor.witness_script)
}

// .signrpc.TxOut output = 5;
inline bool SignDescriptor::has_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_ != nullptr);
  return value;
}
inline void SignDescriptor::clear_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_ != nullptr) _impl_.output_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::signrpc::TxOut& SignDescriptor::_internal_output() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::signrpc::TxOut* p = _impl_.output_;
  return p != nullptr ? *p : reinterpret_cast<const ::signrpc::TxOut&>(::signrpc::_TxOut_default_instance_);
}
inline const ::signrpc::TxOut& SignDescriptor::output() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignDescriptor.output)
  return _internal_output();
}
inline void SignDescriptor::unsafe_arena_set_allocated_output(::signrpc::TxOut* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.output_);
  }
  _impl_.output_ = reinterpret_cast<::signrpc::TxOut*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signrpc.SignDescriptor.output)
}
inline ::signrpc::TxOut* SignDescriptor::release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::signrpc::TxOut* released = _impl_.output_;
  _impl_.output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::signrpc::TxOut* SignDescriptor::unsafe_arena_release_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignDescriptor.output)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::signrpc::TxOut* temp = _impl_.output_;
  _impl_.output_ = nullptr;
  return temp;
}
inline ::signrpc::TxOut* SignDescriptor::_internal_mutable_output() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.output_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::signrpc::TxOut>(GetArena());
    _impl_.output_ = reinterpret_cast<::signrpc::TxOut*>(p);
  }
  return _impl_.output_;
}
inline ::signrpc::TxOut* SignDescriptor::mutable_output() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::signrpc::TxOut* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:signrpc.SignDescriptor.output)
  return _msg;
}
inline void SignDescriptor::set_allocated_output(::signrpc::TxOut* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.output_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.output_ = reinterpret_cast<::signrpc::TxOut*>(value);
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignDescriptor.output)
}

// uint32 sighash = 7;
inline void SignDescriptor::clear_sighash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sighash_ = 0u;
}
inline ::uint32_t SignDescriptor::sighash() const {
  // @@protoc_insertion_point(field_get:signrpc.SignDescriptor.sighash)
  return _internal_sighash();
}
inline void SignDescriptor::set_sighash(::uint32_t value) {
  _internal_set_sighash(value);
  // @@protoc_insertion_point(field_set:signrpc.SignDescriptor.sighash)
}
inline ::uint32_t SignDescriptor::_internal_sighash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sighash_;
}
inline void SignDescriptor::_internal_set_sighash(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sighash_ = value;
}

// int32 input_index = 8;
inline void SignDescriptor::clear_input_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_index_ = 0;
}
inline ::int32_t SignDescriptor::input_index() const {
  // @@protoc_insertion_point(field_get:signrpc.SignDescriptor.input_index)
  return _internal_input_index();
}
inline void SignDescriptor::set_input_index(::int32_t value) {
  _internal_set_input_index(value);
  // @@protoc_insertion_point(field_set:signrpc.SignDescriptor.input_index)
}
inline ::int32_t SignDescriptor::_internal_input_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_index_;
}
inline void SignDescriptor::_internal_set_input_index(::int32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_index_ = value;
}

// .signrpc.SignMethod sign_method = 9;
inline void SignDescriptor::clear_sign_method() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sign_method_ = 0;
}
inline ::signrpc::SignMethod SignDescriptor::sign_method() const {
  // @@protoc_insertion_point(field_get:signrpc.SignDescriptor.sign_method)
  return _internal_sign_method();
}
inline void SignDescriptor::set_sign_method(::signrpc::SignMethod value) {
  _internal_set_sign_method(value);
  // @@protoc_insertion_point(field_set:signrpc.SignDescriptor.sign_method)
}
inline ::signrpc::SignMethod SignDescriptor::_internal_sign_method() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::signrpc::SignMethod>(_impl_.sign_method_);
}
inline void SignDescriptor::_internal_set_sign_method(::signrpc::SignMethod value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sign_method_ = value;
}

// -------------------------------------------------------------------

// SignReq

// bytes raw_tx_bytes = 1;
inline void SignReq::clear_raw_tx_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.raw_tx_bytes_.ClearToEmpty();
}
inline const std::string& SignReq::raw_tx_bytes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignReq.raw_tx_bytes)
  return _internal_raw_tx_bytes();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignReq::set_raw_tx_bytes(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.raw_tx_bytes_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SignReq.raw_tx_bytes)
}
inline std::string* SignReq::mutable_raw_tx_bytes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_raw_tx_bytes();
  // @@protoc_insertion_point(field_mutable:signrpc.SignReq.raw_tx_bytes)
  return _s;
}
inline const std::string& SignReq::_internal_raw_tx_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.raw_tx_bytes_.Get();
}
inline void SignReq::_internal_set_raw_tx_bytes(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.raw_tx_bytes_.Set(value, GetArena());
}
inline std::string* SignReq::_internal_mutable_raw_tx_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.raw_tx_bytes_.Mutable( GetArena());
}
inline std::string* SignReq::release_raw_tx_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignReq.raw_tx_bytes)
  return _impl_.raw_tx_bytes_.Release();
}
inline void SignReq::set_allocated_raw_tx_bytes(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.raw_tx_bytes_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.raw_tx_bytes_.IsDefault()) {
          _impl_.raw_tx_bytes_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignReq.raw_tx_bytes)
}

// repeated .signrpc.SignDescriptor sign_descs = 2;
inline int SignReq::_internal_sign_descs_size() const {
  return _internal_sign_descs().size();
}
inline int SignReq::sign_descs_size() const {
  return _internal_sign_descs_size();
}
inline void SignReq::clear_sign_descs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sign_descs_.Clear();
}
inline ::signrpc::SignDescriptor* SignReq::mutable_sign_descs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.SignReq.sign_descs)
  return _internal_mutable_sign_descs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::signrpc::SignDescriptor>* SignReq::mutable_sign_descs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.SignReq.sign_descs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_sign_descs();
}
inline const ::signrpc::SignDescriptor& SignReq::sign_descs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignReq.sign_descs)
  return _internal_sign_descs().Get(index);
}
inline ::signrpc::SignDescriptor* SignReq::add_sign_descs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::signrpc::SignDescriptor* _add = _internal_mutable_sign_descs()->Add();
  // @@protoc_insertion_point(field_add:signrpc.SignReq.sign_descs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::signrpc::SignDescriptor>& SignReq::sign_descs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.SignReq.sign_descs)
  return _internal_sign_descs();
}
inline const ::google::protobuf::RepeatedPtrField<::signrpc::SignDescriptor>&
SignReq::_internal_sign_descs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sign_descs_;
}
inline ::google::protobuf::RepeatedPtrField<::signrpc::SignDescriptor>*
SignReq::_internal_mutable_sign_descs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.sign_descs_;
}

// repeated .signrpc.TxOut prev_outputs = 3;
inline int SignReq::_internal_prev_outputs_size() const {
  return _internal_prev_outputs().size();
}
inline int SignReq::prev_outputs_size() const {
  return _internal_prev_outputs_size();
}
inline void SignReq::clear_prev_outputs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.prev_outputs_.Clear();
}
inline ::signrpc::TxOut* SignReq::mutable_prev_outputs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.SignReq.prev_outputs)
  return _internal_mutable_prev_outputs()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::signrpc::TxOut>* SignReq::mutable_prev_outputs()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.SignReq.prev_outputs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_prev_outputs();
}
inline const ::signrpc::TxOut& SignReq::prev_outputs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignReq.prev_outputs)
  return _internal_prev_outputs().Get(index);
}
inline ::signrpc::TxOut* SignReq::add_prev_outputs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::signrpc::TxOut* _add = _internal_mutable_prev_outputs()->Add();
  // @@protoc_insertion_point(field_add:signrpc.SignReq.prev_outputs)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::signrpc::TxOut>& SignReq::prev_outputs() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.SignReq.prev_outputs)
  return _internal_prev_outputs();
}
inline const ::google::protobuf::RepeatedPtrField<::signrpc::TxOut>&
SignReq::_internal_prev_outputs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.prev_outputs_;
}
inline ::google::protobuf::RepeatedPtrField<::signrpc::TxOut>*
SignReq::_internal_mutable_prev_outputs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.prev_outputs_;
}

// -------------------------------------------------------------------

// SignResp

// repeated bytes raw_sigs = 1;
inline int SignResp::_internal_raw_sigs_size() const {
  return _internal_raw_sigs().size();
}
inline int SignResp::raw_sigs_size() const {
  return _internal_raw_sigs_size();
}
inline void SignResp::clear_raw_sigs() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.raw_sigs_.Clear();
}
inline std::string* SignResp::add_raw_sigs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_raw_sigs()->Add();
  // @@protoc_insertion_point(field_add_mutable:signrpc.SignResp.raw_sigs)
  return _s;
}
inline const std::string& SignResp::raw_sigs(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignResp.raw_sigs)
  return _internal_raw_sigs().Get(index);
}
inline std::string* SignResp::mutable_raw_sigs(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.SignResp.raw_sigs)
  return _internal_mutable_raw_sigs()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void SignResp::set_raw_sigs(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_raw_sigs()->Mutable(index),
      std::forward<Arg_>(value), args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:signrpc.SignResp.raw_sigs)
}
template <typename Arg_, typename... Args_>
inline void SignResp::add_raw_sigs(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_raw_sigs(),
                               std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:signrpc.SignResp.raw_sigs)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SignResp::raw_sigs() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.SignResp.raw_sigs)
  return _internal_raw_sigs();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SignResp::mutable_raw_sigs() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.SignResp.raw_sigs)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_raw_sigs();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
SignResp::_internal_raw_sigs() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.raw_sigs_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
SignResp::_internal_mutable_raw_sigs() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.raw_sigs_;
}

// -------------------------------------------------------------------

// InputScript

// repeated bytes witness = 1;
inline int InputScript::_internal_witness_size() const {
  return _internal_witness().size();
}
inline int InputScript::witness_size() const {
  return _internal_witness_size();
}
inline void InputScript::clear_witness() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.witness_.Clear();
}
inline std::string* InputScript::add_witness() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_witness()->Add();
  // @@protoc_insertion_point(field_add_mutable:signrpc.InputScript.witness)
  return _s;
}
inline const std::string& InputScript::witness(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.InputScript.witness)
  return _internal_witness().Get(index);
}
inline std::string* InputScript::mutable_witness(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.InputScript.witness)
  return _internal_mutable_witness()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void InputScript::set_witness(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_witness()->Mutable(index),
      std::forward<Arg_>(value), args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:signrpc.InputScript.witness)
}
template <typename Arg_, typename... Args_>
inline void InputScript::add_witness(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_witness(),
                               std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:signrpc.InputScript.witness)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
InputScript::witness() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.InputScript.witness)
  return _internal_witness();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
InputScript::mutable_witness() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.InputScript.witness)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_witness();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
InputScript::_internal_witness() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.witness_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
InputScript::_internal_mutable_witness() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.witness_;
}

// bytes sig_script = 2;
inline void InputScript::clear_sig_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sig_script_.ClearToEmpty();
}
inline const std::string& InputScript::sig_script() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.InputScript.sig_script)
  return _internal_sig_script();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void InputScript::set_sig_script(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sig_script_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.InputScript.sig_script)
}
inline std::string* InputScript::mutable_sig_script() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_sig_script();
  // @@protoc_insertion_point(field_mutable:signrpc.InputScript.sig_script)
  return _s;
}
inline const std::string& InputScript::_internal_sig_script() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.sig_script_.Get();
}
inline void InputScript::_internal_set_sig_script(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sig_script_.Set(value, GetArena());
}
inline std::string* InputScript::_internal_mutable_sig_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.sig_script_.Mutable( GetArena());
}
inline std::string* InputScript::release_sig_script() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.InputScript.sig_script)
  return _impl_.sig_script_.Release();
}
inline void InputScript::set_allocated_sig_script(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.sig_script_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.sig_script_.IsDefault()) {
          _impl_.sig_script_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.InputScript.sig_script)
}

// -------------------------------------------------------------------

// InputScriptResp

// repeated .signrpc.InputScript input_scripts = 1;
inline int InputScriptResp::_internal_input_scripts_size() const {
  return _internal_input_scripts().size();
}
inline int InputScriptResp::input_scripts_size() const {
  return _internal_input_scripts_size();
}
inline void InputScriptResp::clear_input_scripts() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.input_scripts_.Clear();
}
inline ::signrpc::InputScript* InputScriptResp::mutable_input_scripts(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.InputScriptResp.input_scripts)
  return _internal_mutable_input_scripts()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::signrpc::InputScript>* InputScriptResp::mutable_input_scripts()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.InputScriptResp.input_scripts)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_input_scripts();
}
inline const ::signrpc::InputScript& InputScriptResp::input_scripts(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.InputScriptResp.input_scripts)
  return _internal_input_scripts().Get(index);
}
inline ::signrpc::InputScript* InputScriptResp::add_input_scripts() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::signrpc::InputScript* _add = _internal_mutable_input_scripts()->Add();
  // @@protoc_insertion_point(field_add:signrpc.InputScriptResp.input_scripts)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::signrpc::InputScript>& InputScriptResp::input_scripts() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.InputScriptResp.input_scripts)
  return _internal_input_scripts();
}
inline const ::google::protobuf::RepeatedPtrField<::signrpc::InputScript>&
InputScriptResp::_internal_input_scripts() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.input_scripts_;
}
inline ::google::protobuf::RepeatedPtrField<::signrpc::InputScript>*
InputScriptResp::_internal_mutable_input_scripts() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.input_scripts_;
}

// -------------------------------------------------------------------

// SignMessageReq

// bytes msg = 1;
inline void SignMessageReq::clear_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& SignMessageReq::msg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignMessageReq.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignMessageReq::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SignMessageReq.msg)
}
inline std::string* SignMessageReq::mutable_msg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:signrpc.SignMessageReq.msg)
  return _s;
}
inline const std::string& SignMessageReq::_internal_msg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.msg_.Get();
}
inline void SignMessageReq::_internal_set_msg(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.Set(value, GetArena());
}
inline std::string* SignMessageReq::_internal_mutable_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.msg_.Mutable( GetArena());
}
inline std::string* SignMessageReq::release_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignMessageReq.msg)
  return _impl_.msg_.Release();
}
inline void SignMessageReq::set_allocated_msg(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignMessageReq.msg)
}

// .signrpc.KeyLocator key_loc = 2;
inline bool SignMessageReq::has_key_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_loc_ != nullptr);
  return value;
}
inline void SignMessageReq::clear_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_loc_ != nullptr) _impl_.key_loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::signrpc::KeyLocator& SignMessageReq::_internal_key_loc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::signrpc::KeyLocator* p = _impl_.key_loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::signrpc::KeyLocator&>(::signrpc::_KeyLocator_default_instance_);
}
inline const ::signrpc::KeyLocator& SignMessageReq::key_loc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignMessageReq.key_loc)
  return _internal_key_loc();
}
inline void SignMessageReq::unsafe_arena_set_allocated_key_loc(::signrpc::KeyLocator* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_loc_);
  }
  _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signrpc.SignMessageReq.key_loc)
}
inline ::signrpc::KeyLocator* SignMessageReq::release_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::KeyLocator* released = _impl_.key_loc_;
  _impl_.key_loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::signrpc::KeyLocator* SignMessageReq::unsafe_arena_release_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignMessageReq.key_loc)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::KeyLocator* temp = _impl_.key_loc_;
  _impl_.key_loc_ = nullptr;
  return temp;
}
inline ::signrpc::KeyLocator* SignMessageReq::_internal_mutable_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_loc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::signrpc::KeyLocator>(GetArena());
    _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(p);
  }
  return _impl_.key_loc_;
}
inline ::signrpc::KeyLocator* SignMessageReq::mutable_key_loc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::signrpc::KeyLocator* _msg = _internal_mutable_key_loc();
  // @@protoc_insertion_point(field_mutable:signrpc.SignMessageReq.key_loc)
  return _msg;
}
inline void SignMessageReq::set_allocated_key_loc(::signrpc::KeyLocator* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.key_loc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(value);
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignMessageReq.key_loc)
}

// bool double_hash = 3;
inline void SignMessageReq::clear_double_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.double_hash_ = false;
}
inline bool SignMessageReq::double_hash() const {
  // @@protoc_insertion_point(field_get:signrpc.SignMessageReq.double_hash)
  return _internal_double_hash();
}
inline void SignMessageReq::set_double_hash(bool value) {
  _internal_set_double_hash(value);
  // @@protoc_insertion_point(field_set:signrpc.SignMessageReq.double_hash)
}
inline bool SignMessageReq::_internal_double_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.double_hash_;
}
inline void SignMessageReq::_internal_set_double_hash(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.double_hash_ = value;
}

// bool compact_sig = 4;
inline void SignMessageReq::clear_compact_sig() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compact_sig_ = false;
}
inline bool SignMessageReq::compact_sig() const {
  // @@protoc_insertion_point(field_get:signrpc.SignMessageReq.compact_sig)
  return _internal_compact_sig();
}
inline void SignMessageReq::set_compact_sig(bool value) {
  _internal_set_compact_sig(value);
  // @@protoc_insertion_point(field_set:signrpc.SignMessageReq.compact_sig)
}
inline bool SignMessageReq::_internal_compact_sig() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.compact_sig_;
}
inline void SignMessageReq::_internal_set_compact_sig(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.compact_sig_ = value;
}

// bool schnorr_sig = 5;
inline void SignMessageReq::clear_schnorr_sig() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schnorr_sig_ = false;
}
inline bool SignMessageReq::schnorr_sig() const {
  // @@protoc_insertion_point(field_get:signrpc.SignMessageReq.schnorr_sig)
  return _internal_schnorr_sig();
}
inline void SignMessageReq::set_schnorr_sig(bool value) {
  _internal_set_schnorr_sig(value);
  // @@protoc_insertion_point(field_set:signrpc.SignMessageReq.schnorr_sig)
}
inline bool SignMessageReq::_internal_schnorr_sig() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.schnorr_sig_;
}
inline void SignMessageReq::_internal_set_schnorr_sig(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schnorr_sig_ = value;
}

// bytes schnorr_sig_tap_tweak = 6;
inline void SignMessageReq::clear_schnorr_sig_tap_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schnorr_sig_tap_tweak_.ClearToEmpty();
}
inline const std::string& SignMessageReq::schnorr_sig_tap_tweak() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignMessageReq.schnorr_sig_tap_tweak)
  return _internal_schnorr_sig_tap_tweak();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignMessageReq::set_schnorr_sig_tap_tweak(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schnorr_sig_tap_tweak_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SignMessageReq.schnorr_sig_tap_tweak)
}
inline std::string* SignMessageReq::mutable_schnorr_sig_tap_tweak() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_schnorr_sig_tap_tweak();
  // @@protoc_insertion_point(field_mutable:signrpc.SignMessageReq.schnorr_sig_tap_tweak)
  return _s;
}
inline const std::string& SignMessageReq::_internal_schnorr_sig_tap_tweak() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.schnorr_sig_tap_tweak_.Get();
}
inline void SignMessageReq::_internal_set_schnorr_sig_tap_tweak(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schnorr_sig_tap_tweak_.Set(value, GetArena());
}
inline std::string* SignMessageReq::_internal_mutable_schnorr_sig_tap_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.schnorr_sig_tap_tweak_.Mutable( GetArena());
}
inline std::string* SignMessageReq::release_schnorr_sig_tap_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignMessageReq.schnorr_sig_tap_tweak)
  return _impl_.schnorr_sig_tap_tweak_.Release();
}
inline void SignMessageReq::set_allocated_schnorr_sig_tap_tweak(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.schnorr_sig_tap_tweak_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.schnorr_sig_tap_tweak_.IsDefault()) {
          _impl_.schnorr_sig_tap_tweak_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignMessageReq.schnorr_sig_tap_tweak)
}

// bytes tag = 7;
inline void SignMessageReq::clear_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& SignMessageReq::tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignMessageReq.tag)
  return _internal_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignMessageReq::set_tag(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SignMessageReq.tag)
}
inline std::string* SignMessageReq::mutable_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:signrpc.SignMessageReq.tag)
  return _s;
}
inline const std::string& SignMessageReq::_internal_tag() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tag_.Get();
}
inline void SignMessageReq::_internal_set_tag(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.Set(value, GetArena());
}
inline std::string* SignMessageReq::_internal_mutable_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tag_.Mutable( GetArena());
}
inline std::string* SignMessageReq::release_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignMessageReq.tag)
  return _impl_.tag_.Release();
}
inline void SignMessageReq::set_allocated_tag(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tag_.IsDefault()) {
          _impl_.tag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignMessageReq.tag)
}

// -------------------------------------------------------------------

// SignMessageResp

// bytes signature = 1;
inline void SignMessageResp::clear_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& SignMessageResp::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SignMessageResp.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SignMessageResp::set_signature(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SignMessageResp.signature)
}
inline std::string* SignMessageResp::mutable_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:signrpc.SignMessageResp.signature)
  return _s;
}
inline const std::string& SignMessageResp::_internal_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_.Get();
}
inline void SignMessageResp::_internal_set_signature(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.Set(value, GetArena());
}
inline std::string* SignMessageResp::_internal_mutable_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.signature_.Mutable( GetArena());
}
inline std::string* SignMessageResp::release_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SignMessageResp.signature)
  return _impl_.signature_.Release();
}
inline void SignMessageResp::set_allocated_signature(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signature_.IsDefault()) {
          _impl_.signature_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SignMessageResp.signature)
}

// -------------------------------------------------------------------

// VerifyMessageReq

// bytes msg = 1;
inline void VerifyMessageReq::clear_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.ClearToEmpty();
}
inline const std::string& VerifyMessageReq::msg() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.VerifyMessageReq.msg)
  return _internal_msg();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerifyMessageReq::set_msg(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.VerifyMessageReq.msg)
}
inline std::string* VerifyMessageReq::mutable_msg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_msg();
  // @@protoc_insertion_point(field_mutable:signrpc.VerifyMessageReq.msg)
  return _s;
}
inline const std::string& VerifyMessageReq::_internal_msg() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.msg_.Get();
}
inline void VerifyMessageReq::_internal_set_msg(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.Set(value, GetArena());
}
inline std::string* VerifyMessageReq::_internal_mutable_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.msg_.Mutable( GetArena());
}
inline std::string* VerifyMessageReq::release_msg() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.VerifyMessageReq.msg)
  return _impl_.msg_.Release();
}
inline void VerifyMessageReq::set_allocated_msg(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.msg_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.msg_.IsDefault()) {
          _impl_.msg_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.VerifyMessageReq.msg)
}

// bytes signature = 2;
inline void VerifyMessageReq::clear_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.ClearToEmpty();
}
inline const std::string& VerifyMessageReq::signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.VerifyMessageReq.signature)
  return _internal_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerifyMessageReq::set_signature(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.VerifyMessageReq.signature)
}
inline std::string* VerifyMessageReq::mutable_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:signrpc.VerifyMessageReq.signature)
  return _s;
}
inline const std::string& VerifyMessageReq::_internal_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.signature_.Get();
}
inline void VerifyMessageReq::_internal_set_signature(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.Set(value, GetArena());
}
inline std::string* VerifyMessageReq::_internal_mutable_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.signature_.Mutable( GetArena());
}
inline std::string* VerifyMessageReq::release_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.VerifyMessageReq.signature)
  return _impl_.signature_.Release();
}
inline void VerifyMessageReq::set_allocated_signature(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.signature_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.signature_.IsDefault()) {
          _impl_.signature_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.VerifyMessageReq.signature)
}

// bytes pubkey = 3;
inline void VerifyMessageReq::clear_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pubkey_.ClearToEmpty();
}
inline const std::string& VerifyMessageReq::pubkey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.VerifyMessageReq.pubkey)
  return _internal_pubkey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerifyMessageReq::set_pubkey(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pubkey_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.VerifyMessageReq.pubkey)
}
inline std::string* VerifyMessageReq::mutable_pubkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pubkey();
  // @@protoc_insertion_point(field_mutable:signrpc.VerifyMessageReq.pubkey)
  return _s;
}
inline const std::string& VerifyMessageReq::_internal_pubkey() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pubkey_.Get();
}
inline void VerifyMessageReq::_internal_set_pubkey(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pubkey_.Set(value, GetArena());
}
inline std::string* VerifyMessageReq::_internal_mutable_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pubkey_.Mutable( GetArena());
}
inline std::string* VerifyMessageReq::release_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.VerifyMessageReq.pubkey)
  return _impl_.pubkey_.Release();
}
inline void VerifyMessageReq::set_allocated_pubkey(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pubkey_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pubkey_.IsDefault()) {
          _impl_.pubkey_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.VerifyMessageReq.pubkey)
}

// bool is_schnorr_sig = 4;
inline void VerifyMessageReq::clear_is_schnorr_sig() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_schnorr_sig_ = false;
}
inline bool VerifyMessageReq::is_schnorr_sig() const {
  // @@protoc_insertion_point(field_get:signrpc.VerifyMessageReq.is_schnorr_sig)
  return _internal_is_schnorr_sig();
}
inline void VerifyMessageReq::set_is_schnorr_sig(bool value) {
  _internal_set_is_schnorr_sig(value);
  // @@protoc_insertion_point(field_set:signrpc.VerifyMessageReq.is_schnorr_sig)
}
inline bool VerifyMessageReq::_internal_is_schnorr_sig() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_schnorr_sig_;
}
inline void VerifyMessageReq::_internal_set_is_schnorr_sig(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_schnorr_sig_ = value;
}

// bytes tag = 5;
inline void VerifyMessageReq::clear_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.ClearToEmpty();
}
inline const std::string& VerifyMessageReq::tag() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.VerifyMessageReq.tag)
  return _internal_tag();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void VerifyMessageReq::set_tag(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.VerifyMessageReq.tag)
}
inline std::string* VerifyMessageReq::mutable_tag() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:signrpc.VerifyMessageReq.tag)
  return _s;
}
inline const std::string& VerifyMessageReq::_internal_tag() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tag_.Get();
}
inline void VerifyMessageReq::_internal_set_tag(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.Set(value, GetArena());
}
inline std::string* VerifyMessageReq::_internal_mutable_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tag_.Mutable( GetArena());
}
inline std::string* VerifyMessageReq::release_tag() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.VerifyMessageReq.tag)
  return _impl_.tag_.Release();
}
inline void VerifyMessageReq::set_allocated_tag(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tag_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tag_.IsDefault()) {
          _impl_.tag_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.VerifyMessageReq.tag)
}

// -------------------------------------------------------------------

// VerifyMessageResp

// bool valid = 1;
inline void VerifyMessageResp::clear_valid() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.valid_ = false;
}
inline bool VerifyMessageResp::valid() const {
  // @@protoc_insertion_point(field_get:signrpc.VerifyMessageResp.valid)
  return _internal_valid();
}
inline void VerifyMessageResp::set_valid(bool value) {
  _internal_set_valid(value);
  // @@protoc_insertion_point(field_set:signrpc.VerifyMessageResp.valid)
}
inline bool VerifyMessageResp::_internal_valid() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.valid_;
}
inline void VerifyMessageResp::_internal_set_valid(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.valid_ = value;
}

// -------------------------------------------------------------------

// SharedKeyRequest

// bytes ephemeral_pubkey = 1;
inline void SharedKeyRequest::clear_ephemeral_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ephemeral_pubkey_.ClearToEmpty();
}
inline const std::string& SharedKeyRequest::ephemeral_pubkey() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SharedKeyRequest.ephemeral_pubkey)
  return _internal_ephemeral_pubkey();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SharedKeyRequest::set_ephemeral_pubkey(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ephemeral_pubkey_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SharedKeyRequest.ephemeral_pubkey)
}
inline std::string* SharedKeyRequest::mutable_ephemeral_pubkey() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_ephemeral_pubkey();
  // @@protoc_insertion_point(field_mutable:signrpc.SharedKeyRequest.ephemeral_pubkey)
  return _s;
}
inline const std::string& SharedKeyRequest::_internal_ephemeral_pubkey() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.ephemeral_pubkey_.Get();
}
inline void SharedKeyRequest::_internal_set_ephemeral_pubkey(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ephemeral_pubkey_.Set(value, GetArena());
}
inline std::string* SharedKeyRequest::_internal_mutable_ephemeral_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.ephemeral_pubkey_.Mutable( GetArena());
}
inline std::string* SharedKeyRequest::release_ephemeral_pubkey() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SharedKeyRequest.ephemeral_pubkey)
  return _impl_.ephemeral_pubkey_.Release();
}
inline void SharedKeyRequest::set_allocated_ephemeral_pubkey(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.ephemeral_pubkey_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.ephemeral_pubkey_.IsDefault()) {
          _impl_.ephemeral_pubkey_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SharedKeyRequest.ephemeral_pubkey)
}

// .signrpc.KeyLocator key_loc = 2 [deprecated = true];
inline bool SharedKeyRequest::has_key_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_loc_ != nullptr);
  return value;
}
inline void SharedKeyRequest::clear_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_loc_ != nullptr) _impl_.key_loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::signrpc::KeyLocator& SharedKeyRequest::_internal_key_loc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::signrpc::KeyLocator* p = _impl_.key_loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::signrpc::KeyLocator&>(::signrpc::_KeyLocator_default_instance_);
}
inline const ::signrpc::KeyLocator& SharedKeyRequest::key_loc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SharedKeyRequest.key_loc)
  return _internal_key_loc();
}
inline void SharedKeyRequest::unsafe_arena_set_allocated_key_loc(::signrpc::KeyLocator* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_loc_);
  }
  _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signrpc.SharedKeyRequest.key_loc)
}
inline ::signrpc::KeyLocator* SharedKeyRequest::release_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::KeyLocator* released = _impl_.key_loc_;
  _impl_.key_loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::signrpc::KeyLocator* SharedKeyRequest::unsafe_arena_release_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SharedKeyRequest.key_loc)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::KeyLocator* temp = _impl_.key_loc_;
  _impl_.key_loc_ = nullptr;
  return temp;
}
inline ::signrpc::KeyLocator* SharedKeyRequest::_internal_mutable_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_loc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::signrpc::KeyLocator>(GetArena());
    _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(p);
  }
  return _impl_.key_loc_;
}
inline ::signrpc::KeyLocator* SharedKeyRequest::mutable_key_loc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::signrpc::KeyLocator* _msg = _internal_mutable_key_loc();
  // @@protoc_insertion_point(field_mutable:signrpc.SharedKeyRequest.key_loc)
  return _msg;
}
inline void SharedKeyRequest::set_allocated_key_loc(::signrpc::KeyLocator* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.key_loc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(value);
  // @@protoc_insertion_point(field_set_allocated:signrpc.SharedKeyRequest.key_loc)
}

// .signrpc.KeyDescriptor key_desc = 3;
inline bool SharedKeyRequest::has_key_desc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_desc_ != nullptr);
  return value;
}
inline void SharedKeyRequest::clear_key_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_desc_ != nullptr) _impl_.key_desc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::signrpc::KeyDescriptor& SharedKeyRequest::_internal_key_desc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::signrpc::KeyDescriptor* p = _impl_.key_desc_;
  return p != nullptr ? *p : reinterpret_cast<const ::signrpc::KeyDescriptor&>(::signrpc::_KeyDescriptor_default_instance_);
}
inline const ::signrpc::KeyDescriptor& SharedKeyRequest::key_desc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SharedKeyRequest.key_desc)
  return _internal_key_desc();
}
inline void SharedKeyRequest::unsafe_arena_set_allocated_key_desc(::signrpc::KeyDescriptor* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_desc_);
  }
  _impl_.key_desc_ = reinterpret_cast<::signrpc::KeyDescriptor*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signrpc.SharedKeyRequest.key_desc)
}
inline ::signrpc::KeyDescriptor* SharedKeyRequest::release_key_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::signrpc::KeyDescriptor* released = _impl_.key_desc_;
  _impl_.key_desc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::signrpc::KeyDescriptor* SharedKeyRequest::unsafe_arena_release_key_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SharedKeyRequest.key_desc)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::signrpc::KeyDescriptor* temp = _impl_.key_desc_;
  _impl_.key_desc_ = nullptr;
  return temp;
}
inline ::signrpc::KeyDescriptor* SharedKeyRequest::_internal_mutable_key_desc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_desc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::signrpc::KeyDescriptor>(GetArena());
    _impl_.key_desc_ = reinterpret_cast<::signrpc::KeyDescriptor*>(p);
  }
  return _impl_.key_desc_;
}
inline ::signrpc::KeyDescriptor* SharedKeyRequest::mutable_key_desc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::signrpc::KeyDescriptor* _msg = _internal_mutable_key_desc();
  // @@protoc_insertion_point(field_mutable:signrpc.SharedKeyRequest.key_desc)
  return _msg;
}
inline void SharedKeyRequest::set_allocated_key_desc(::signrpc::KeyDescriptor* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.key_desc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.key_desc_ = reinterpret_cast<::signrpc::KeyDescriptor*>(value);
  // @@protoc_insertion_point(field_set_allocated:signrpc.SharedKeyRequest.key_desc)
}

// -------------------------------------------------------------------

// SharedKeyResponse

// bytes shared_key = 1;
inline void SharedKeyResponse::clear_shared_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shared_key_.ClearToEmpty();
}
inline const std::string& SharedKeyResponse::shared_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.SharedKeyResponse.shared_key)
  return _internal_shared_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SharedKeyResponse::set_shared_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shared_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.SharedKeyResponse.shared_key)
}
inline std::string* SharedKeyResponse::mutable_shared_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shared_key();
  // @@protoc_insertion_point(field_mutable:signrpc.SharedKeyResponse.shared_key)
  return _s;
}
inline const std::string& SharedKeyResponse::_internal_shared_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shared_key_.Get();
}
inline void SharedKeyResponse::_internal_set_shared_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shared_key_.Set(value, GetArena());
}
inline std::string* SharedKeyResponse::_internal_mutable_shared_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.shared_key_.Mutable( GetArena());
}
inline std::string* SharedKeyResponse::release_shared_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.SharedKeyResponse.shared_key)
  return _impl_.shared_key_.Release();
}
inline void SharedKeyResponse::set_allocated_shared_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shared_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.shared_key_.IsDefault()) {
          _impl_.shared_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.SharedKeyResponse.shared_key)
}

// -------------------------------------------------------------------

// TweakDesc

// bytes tweak = 1;
inline void TweakDesc::clear_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tweak_.ClearToEmpty();
}
inline const std::string& TweakDesc::tweak() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.TweakDesc.tweak)
  return _internal_tweak();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TweakDesc::set_tweak(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tweak_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.TweakDesc.tweak)
}
inline std::string* TweakDesc::mutable_tweak() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tweak();
  // @@protoc_insertion_point(field_mutable:signrpc.TweakDesc.tweak)
  return _s;
}
inline const std::string& TweakDesc::_internal_tweak() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tweak_.Get();
}
inline void TweakDesc::_internal_set_tweak(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tweak_.Set(value, GetArena());
}
inline std::string* TweakDesc::_internal_mutable_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tweak_.Mutable( GetArena());
}
inline std::string* TweakDesc::release_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.TweakDesc.tweak)
  return _impl_.tweak_.Release();
}
inline void TweakDesc::set_allocated_tweak(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tweak_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.tweak_.IsDefault()) {
          _impl_.tweak_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.TweakDesc.tweak)
}

// bool is_x_only = 2;
inline void TweakDesc::clear_is_x_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_x_only_ = false;
}
inline bool TweakDesc::is_x_only() const {
  // @@protoc_insertion_point(field_get:signrpc.TweakDesc.is_x_only)
  return _internal_is_x_only();
}
inline void TweakDesc::set_is_x_only(bool value) {
  _internal_set_is_x_only(value);
  // @@protoc_insertion_point(field_set:signrpc.TweakDesc.is_x_only)
}
inline bool TweakDesc::_internal_is_x_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.is_x_only_;
}
inline void TweakDesc::_internal_set_is_x_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.is_x_only_ = value;
}

// -------------------------------------------------------------------

// TaprootTweakDesc

// bytes script_root = 1;
inline void TaprootTweakDesc::clear_script_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.script_root_.ClearToEmpty();
}
inline const std::string& TaprootTweakDesc::script_root() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.TaprootTweakDesc.script_root)
  return _internal_script_root();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TaprootTweakDesc::set_script_root(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.script_root_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.TaprootTweakDesc.script_root)
}
inline std::string* TaprootTweakDesc::mutable_script_root() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_script_root();
  // @@protoc_insertion_point(field_mutable:signrpc.TaprootTweakDesc.script_root)
  return _s;
}
inline const std::string& TaprootTweakDesc::_internal_script_root() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.script_root_.Get();
}
inline void TaprootTweakDesc::_internal_set_script_root(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.script_root_.Set(value, GetArena());
}
inline std::string* TaprootTweakDesc::_internal_mutable_script_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.script_root_.Mutable( GetArena());
}
inline std::string* TaprootTweakDesc::release_script_root() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.TaprootTweakDesc.script_root)
  return _impl_.script_root_.Release();
}
inline void TaprootTweakDesc::set_allocated_script_root(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.script_root_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.script_root_.IsDefault()) {
          _impl_.script_root_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.TaprootTweakDesc.script_root)
}

// bool key_spend_only = 2;
inline void TaprootTweakDesc::clear_key_spend_only() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_spend_only_ = false;
}
inline bool TaprootTweakDesc::key_spend_only() const {
  // @@protoc_insertion_point(field_get:signrpc.TaprootTweakDesc.key_spend_only)
  return _internal_key_spend_only();
}
inline void TaprootTweakDesc::set_key_spend_only(bool value) {
  _internal_set_key_spend_only(value);
  // @@protoc_insertion_point(field_set:signrpc.TaprootTweakDesc.key_spend_only)
}
inline bool TaprootTweakDesc::_internal_key_spend_only() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.key_spend_only_;
}
inline void TaprootTweakDesc::_internal_set_key_spend_only(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.key_spend_only_ = value;
}

// -------------------------------------------------------------------

// MuSig2CombineKeysRequest

// repeated bytes all_signer_pubkeys = 1;
inline int MuSig2CombineKeysRequest::_internal_all_signer_pubkeys_size() const {
  return _internal_all_signer_pubkeys().size();
}
inline int MuSig2CombineKeysRequest::all_signer_pubkeys_size() const {
  return _internal_all_signer_pubkeys_size();
}
inline void MuSig2CombineKeysRequest::clear_all_signer_pubkeys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_signer_pubkeys_.Clear();
}
inline std::string* MuSig2CombineKeysRequest::add_all_signer_pubkeys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_all_signer_pubkeys()->Add();
  // @@protoc_insertion_point(field_add_mutable:signrpc.MuSig2CombineKeysRequest.all_signer_pubkeys)
  return _s;
}
inline const std::string& MuSig2CombineKeysRequest::all_signer_pubkeys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineKeysRequest.all_signer_pubkeys)
  return _internal_all_signer_pubkeys().Get(index);
}
inline std::string* MuSig2CombineKeysRequest::mutable_all_signer_pubkeys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2CombineKeysRequest.all_signer_pubkeys)
  return _internal_mutable_all_signer_pubkeys()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void MuSig2CombineKeysRequest::set_all_signer_pubkeys(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_all_signer_pubkeys()->Mutable(index),
      std::forward<Arg_>(value), args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:signrpc.MuSig2CombineKeysRequest.all_signer_pubkeys)
}
template <typename Arg_, typename... Args_>
inline void MuSig2CombineKeysRequest::add_all_signer_pubkeys(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_all_signer_pubkeys(),
                               std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:signrpc.MuSig2CombineKeysRequest.all_signer_pubkeys)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MuSig2CombineKeysRequest::all_signer_pubkeys() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.MuSig2CombineKeysRequest.all_signer_pubkeys)
  return _internal_all_signer_pubkeys();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MuSig2CombineKeysRequest::mutable_all_signer_pubkeys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.MuSig2CombineKeysRequest.all_signer_pubkeys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_all_signer_pubkeys();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MuSig2CombineKeysRequest::_internal_all_signer_pubkeys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.all_signer_pubkeys_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MuSig2CombineKeysRequest::_internal_mutable_all_signer_pubkeys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.all_signer_pubkeys_;
}

// repeated .signrpc.TweakDesc tweaks = 2;
inline int MuSig2CombineKeysRequest::_internal_tweaks_size() const {
  return _internal_tweaks().size();
}
inline int MuSig2CombineKeysRequest::tweaks_size() const {
  return _internal_tweaks_size();
}
inline void MuSig2CombineKeysRequest::clear_tweaks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tweaks_.Clear();
}
inline ::signrpc::TweakDesc* MuSig2CombineKeysRequest::mutable_tweaks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2CombineKeysRequest.tweaks)
  return _internal_mutable_tweaks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>* MuSig2CombineKeysRequest::mutable_tweaks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.MuSig2CombineKeysRequest.tweaks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tweaks();
}
inline const ::signrpc::TweakDesc& MuSig2CombineKeysRequest::tweaks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineKeysRequest.tweaks)
  return _internal_tweaks().Get(index);
}
inline ::signrpc::TweakDesc* MuSig2CombineKeysRequest::add_tweaks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::signrpc::TweakDesc* _add = _internal_mutable_tweaks()->Add();
  // @@protoc_insertion_point(field_add:signrpc.MuSig2CombineKeysRequest.tweaks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>& MuSig2CombineKeysRequest::tweaks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.MuSig2CombineKeysRequest.tweaks)
  return _internal_tweaks();
}
inline const ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>&
MuSig2CombineKeysRequest::_internal_tweaks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tweaks_;
}
inline ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>*
MuSig2CombineKeysRequest::_internal_mutable_tweaks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tweaks_;
}

// .signrpc.TaprootTweakDesc taproot_tweak = 3;
inline bool MuSig2CombineKeysRequest::has_taproot_tweak() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.taproot_tweak_ != nullptr);
  return value;
}
inline void MuSig2CombineKeysRequest::clear_taproot_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.taproot_tweak_ != nullptr) _impl_.taproot_tweak_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::signrpc::TaprootTweakDesc& MuSig2CombineKeysRequest::_internal_taproot_tweak() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::signrpc::TaprootTweakDesc* p = _impl_.taproot_tweak_;
  return p != nullptr ? *p : reinterpret_cast<const ::signrpc::TaprootTweakDesc&>(::signrpc::_TaprootTweakDesc_default_instance_);
}
inline const ::signrpc::TaprootTweakDesc& MuSig2CombineKeysRequest::taproot_tweak() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineKeysRequest.taproot_tweak)
  return _internal_taproot_tweak();
}
inline void MuSig2CombineKeysRequest::unsafe_arena_set_allocated_taproot_tweak(::signrpc::TaprootTweakDesc* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.taproot_tweak_);
  }
  _impl_.taproot_tweak_ = reinterpret_cast<::signrpc::TaprootTweakDesc*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signrpc.MuSig2CombineKeysRequest.taproot_tweak)
}
inline ::signrpc::TaprootTweakDesc* MuSig2CombineKeysRequest::release_taproot_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::TaprootTweakDesc* released = _impl_.taproot_tweak_;
  _impl_.taproot_tweak_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::signrpc::TaprootTweakDesc* MuSig2CombineKeysRequest::unsafe_arena_release_taproot_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2CombineKeysRequest.taproot_tweak)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::TaprootTweakDesc* temp = _impl_.taproot_tweak_;
  _impl_.taproot_tweak_ = nullptr;
  return temp;
}
inline ::signrpc::TaprootTweakDesc* MuSig2CombineKeysRequest::_internal_mutable_taproot_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.taproot_tweak_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::signrpc::TaprootTweakDesc>(GetArena());
    _impl_.taproot_tweak_ = reinterpret_cast<::signrpc::TaprootTweakDesc*>(p);
  }
  return _impl_.taproot_tweak_;
}
inline ::signrpc::TaprootTweakDesc* MuSig2CombineKeysRequest::mutable_taproot_tweak() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::signrpc::TaprootTweakDesc* _msg = _internal_mutable_taproot_tweak();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2CombineKeysRequest.taproot_tweak)
  return _msg;
}
inline void MuSig2CombineKeysRequest::set_allocated_taproot_tweak(::signrpc::TaprootTweakDesc* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.taproot_tweak_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.taproot_tweak_ = reinterpret_cast<::signrpc::TaprootTweakDesc*>(value);
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2CombineKeysRequest.taproot_tweak)
}

// .signrpc.MuSig2Version version = 4;
inline void MuSig2CombineKeysRequest::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0;
}
inline ::signrpc::MuSig2Version MuSig2CombineKeysRequest::version() const {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineKeysRequest.version)
  return _internal_version();
}
inline void MuSig2CombineKeysRequest::set_version(::signrpc::MuSig2Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:signrpc.MuSig2CombineKeysRequest.version)
}
inline ::signrpc::MuSig2Version MuSig2CombineKeysRequest::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::signrpc::MuSig2Version>(_impl_.version_);
}
inline void MuSig2CombineKeysRequest::_internal_set_version(::signrpc::MuSig2Version value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// -------------------------------------------------------------------

// MuSig2CombineKeysResponse

// bytes combined_key = 1;
inline void MuSig2CombineKeysResponse::clear_combined_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combined_key_.ClearToEmpty();
}
inline const std::string& MuSig2CombineKeysResponse::combined_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineKeysResponse.combined_key)
  return _internal_combined_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2CombineKeysResponse::set_combined_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combined_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2CombineKeysResponse.combined_key)
}
inline std::string* MuSig2CombineKeysResponse::mutable_combined_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_combined_key();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2CombineKeysResponse.combined_key)
  return _s;
}
inline const std::string& MuSig2CombineKeysResponse::_internal_combined_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.combined_key_.Get();
}
inline void MuSig2CombineKeysResponse::_internal_set_combined_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combined_key_.Set(value, GetArena());
}
inline std::string* MuSig2CombineKeysResponse::_internal_mutable_combined_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.combined_key_.Mutable( GetArena());
}
inline std::string* MuSig2CombineKeysResponse::release_combined_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2CombineKeysResponse.combined_key)
  return _impl_.combined_key_.Release();
}
inline void MuSig2CombineKeysResponse::set_allocated_combined_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combined_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.combined_key_.IsDefault()) {
          _impl_.combined_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2CombineKeysResponse.combined_key)
}

// bytes taproot_internal_key = 2;
inline void MuSig2CombineKeysResponse::clear_taproot_internal_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.taproot_internal_key_.ClearToEmpty();
}
inline const std::string& MuSig2CombineKeysResponse::taproot_internal_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineKeysResponse.taproot_internal_key)
  return _internal_taproot_internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2CombineKeysResponse::set_taproot_internal_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.taproot_internal_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2CombineKeysResponse.taproot_internal_key)
}
inline std::string* MuSig2CombineKeysResponse::mutable_taproot_internal_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_taproot_internal_key();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2CombineKeysResponse.taproot_internal_key)
  return _s;
}
inline const std::string& MuSig2CombineKeysResponse::_internal_taproot_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.taproot_internal_key_.Get();
}
inline void MuSig2CombineKeysResponse::_internal_set_taproot_internal_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.taproot_internal_key_.Set(value, GetArena());
}
inline std::string* MuSig2CombineKeysResponse::_internal_mutable_taproot_internal_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.taproot_internal_key_.Mutable( GetArena());
}
inline std::string* MuSig2CombineKeysResponse::release_taproot_internal_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2CombineKeysResponse.taproot_internal_key)
  return _impl_.taproot_internal_key_.Release();
}
inline void MuSig2CombineKeysResponse::set_allocated_taproot_internal_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.taproot_internal_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taproot_internal_key_.IsDefault()) {
          _impl_.taproot_internal_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2CombineKeysResponse.taproot_internal_key)
}

// .signrpc.MuSig2Version version = 4;
inline void MuSig2CombineKeysResponse::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0;
}
inline ::signrpc::MuSig2Version MuSig2CombineKeysResponse::version() const {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineKeysResponse.version)
  return _internal_version();
}
inline void MuSig2CombineKeysResponse::set_version(::signrpc::MuSig2Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:signrpc.MuSig2CombineKeysResponse.version)
}
inline ::signrpc::MuSig2Version MuSig2CombineKeysResponse::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::signrpc::MuSig2Version>(_impl_.version_);
}
inline void MuSig2CombineKeysResponse::_internal_set_version(::signrpc::MuSig2Version value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// -------------------------------------------------------------------

// MuSig2SessionRequest

// .signrpc.KeyLocator key_loc = 1;
inline bool MuSig2SessionRequest::has_key_loc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_loc_ != nullptr);
  return value;
}
inline void MuSig2SessionRequest::clear_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_loc_ != nullptr) _impl_.key_loc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::signrpc::KeyLocator& MuSig2SessionRequest::_internal_key_loc() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::signrpc::KeyLocator* p = _impl_.key_loc_;
  return p != nullptr ? *p : reinterpret_cast<const ::signrpc::KeyLocator&>(::signrpc::_KeyLocator_default_instance_);
}
inline const ::signrpc::KeyLocator& MuSig2SessionRequest::key_loc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionRequest.key_loc)
  return _internal_key_loc();
}
inline void MuSig2SessionRequest::unsafe_arena_set_allocated_key_loc(::signrpc::KeyLocator* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_loc_);
  }
  _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signrpc.MuSig2SessionRequest.key_loc)
}
inline ::signrpc::KeyLocator* MuSig2SessionRequest::release_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::KeyLocator* released = _impl_.key_loc_;
  _impl_.key_loc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::signrpc::KeyLocator* MuSig2SessionRequest::unsafe_arena_release_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2SessionRequest.key_loc)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::signrpc::KeyLocator* temp = _impl_.key_loc_;
  _impl_.key_loc_ = nullptr;
  return temp;
}
inline ::signrpc::KeyLocator* MuSig2SessionRequest::_internal_mutable_key_loc() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.key_loc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::signrpc::KeyLocator>(GetArena());
    _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(p);
  }
  return _impl_.key_loc_;
}
inline ::signrpc::KeyLocator* MuSig2SessionRequest::mutable_key_loc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::signrpc::KeyLocator* _msg = _internal_mutable_key_loc();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SessionRequest.key_loc)
  return _msg;
}
inline void MuSig2SessionRequest::set_allocated_key_loc(::signrpc::KeyLocator* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.key_loc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.key_loc_ = reinterpret_cast<::signrpc::KeyLocator*>(value);
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2SessionRequest.key_loc)
}

// repeated bytes all_signer_pubkeys = 2;
inline int MuSig2SessionRequest::_internal_all_signer_pubkeys_size() const {
  return _internal_all_signer_pubkeys().size();
}
inline int MuSig2SessionRequest::all_signer_pubkeys_size() const {
  return _internal_all_signer_pubkeys_size();
}
inline void MuSig2SessionRequest::clear_all_signer_pubkeys() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.all_signer_pubkeys_.Clear();
}
inline std::string* MuSig2SessionRequest::add_all_signer_pubkeys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_all_signer_pubkeys()->Add();
  // @@protoc_insertion_point(field_add_mutable:signrpc.MuSig2SessionRequest.all_signer_pubkeys)
  return _s;
}
inline const std::string& MuSig2SessionRequest::all_signer_pubkeys(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionRequest.all_signer_pubkeys)
  return _internal_all_signer_pubkeys().Get(index);
}
inline std::string* MuSig2SessionRequest::mutable_all_signer_pubkeys(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SessionRequest.all_signer_pubkeys)
  return _internal_mutable_all_signer_pubkeys()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void MuSig2SessionRequest::set_all_signer_pubkeys(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_all_signer_pubkeys()->Mutable(index),
      std::forward<Arg_>(value), args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SessionRequest.all_signer_pubkeys)
}
template <typename Arg_, typename... Args_>
inline void MuSig2SessionRequest::add_all_signer_pubkeys(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_all_signer_pubkeys(),
                               std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:signrpc.MuSig2SessionRequest.all_signer_pubkeys)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MuSig2SessionRequest::all_signer_pubkeys() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.MuSig2SessionRequest.all_signer_pubkeys)
  return _internal_all_signer_pubkeys();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MuSig2SessionRequest::mutable_all_signer_pubkeys() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.MuSig2SessionRequest.all_signer_pubkeys)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_all_signer_pubkeys();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MuSig2SessionRequest::_internal_all_signer_pubkeys() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.all_signer_pubkeys_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MuSig2SessionRequest::_internal_mutable_all_signer_pubkeys() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.all_signer_pubkeys_;
}

// repeated bytes other_signer_public_nonces = 3;
inline int MuSig2SessionRequest::_internal_other_signer_public_nonces_size() const {
  return _internal_other_signer_public_nonces().size();
}
inline int MuSig2SessionRequest::other_signer_public_nonces_size() const {
  return _internal_other_signer_public_nonces_size();
}
inline void MuSig2SessionRequest::clear_other_signer_public_nonces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_signer_public_nonces_.Clear();
}
inline std::string* MuSig2SessionRequest::add_other_signer_public_nonces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_other_signer_public_nonces()->Add();
  // @@protoc_insertion_point(field_add_mutable:signrpc.MuSig2SessionRequest.other_signer_public_nonces)
  return _s;
}
inline const std::string& MuSig2SessionRequest::other_signer_public_nonces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionRequest.other_signer_public_nonces)
  return _internal_other_signer_public_nonces().Get(index);
}
inline std::string* MuSig2SessionRequest::mutable_other_signer_public_nonces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SessionRequest.other_signer_public_nonces)
  return _internal_mutable_other_signer_public_nonces()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void MuSig2SessionRequest::set_other_signer_public_nonces(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_other_signer_public_nonces()->Mutable(index),
      std::forward<Arg_>(value), args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SessionRequest.other_signer_public_nonces)
}
template <typename Arg_, typename... Args_>
inline void MuSig2SessionRequest::add_other_signer_public_nonces(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_other_signer_public_nonces(),
                               std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:signrpc.MuSig2SessionRequest.other_signer_public_nonces)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MuSig2SessionRequest::other_signer_public_nonces() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.MuSig2SessionRequest.other_signer_public_nonces)
  return _internal_other_signer_public_nonces();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MuSig2SessionRequest::mutable_other_signer_public_nonces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.MuSig2SessionRequest.other_signer_public_nonces)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_other_signer_public_nonces();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MuSig2SessionRequest::_internal_other_signer_public_nonces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.other_signer_public_nonces_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MuSig2SessionRequest::_internal_mutable_other_signer_public_nonces() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.other_signer_public_nonces_;
}

// repeated .signrpc.TweakDesc tweaks = 4;
inline int MuSig2SessionRequest::_internal_tweaks_size() const {
  return _internal_tweaks().size();
}
inline int MuSig2SessionRequest::tweaks_size() const {
  return _internal_tweaks_size();
}
inline void MuSig2SessionRequest::clear_tweaks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tweaks_.Clear();
}
inline ::signrpc::TweakDesc* MuSig2SessionRequest::mutable_tweaks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SessionRequest.tweaks)
  return _internal_mutable_tweaks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>* MuSig2SessionRequest::mutable_tweaks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.MuSig2SessionRequest.tweaks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_tweaks();
}
inline const ::signrpc::TweakDesc& MuSig2SessionRequest::tweaks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionRequest.tweaks)
  return _internal_tweaks().Get(index);
}
inline ::signrpc::TweakDesc* MuSig2SessionRequest::add_tweaks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::signrpc::TweakDesc* _add = _internal_mutable_tweaks()->Add();
  // @@protoc_insertion_point(field_add:signrpc.MuSig2SessionRequest.tweaks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>& MuSig2SessionRequest::tweaks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.MuSig2SessionRequest.tweaks)
  return _internal_tweaks();
}
inline const ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>&
MuSig2SessionRequest::_internal_tweaks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tweaks_;
}
inline ::google::protobuf::RepeatedPtrField<::signrpc::TweakDesc>*
MuSig2SessionRequest::_internal_mutable_tweaks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.tweaks_;
}

// .signrpc.TaprootTweakDesc taproot_tweak = 5;
inline bool MuSig2SessionRequest::has_taproot_tweak() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.taproot_tweak_ != nullptr);
  return value;
}
inline void MuSig2SessionRequest::clear_taproot_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.taproot_tweak_ != nullptr) _impl_.taproot_tweak_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::signrpc::TaprootTweakDesc& MuSig2SessionRequest::_internal_taproot_tweak() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::signrpc::TaprootTweakDesc* p = _impl_.taproot_tweak_;
  return p != nullptr ? *p : reinterpret_cast<const ::signrpc::TaprootTweakDesc&>(::signrpc::_TaprootTweakDesc_default_instance_);
}
inline const ::signrpc::TaprootTweakDesc& MuSig2SessionRequest::taproot_tweak() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionRequest.taproot_tweak)
  return _internal_taproot_tweak();
}
inline void MuSig2SessionRequest::unsafe_arena_set_allocated_taproot_tweak(::signrpc::TaprootTweakDesc* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.taproot_tweak_);
  }
  _impl_.taproot_tweak_ = reinterpret_cast<::signrpc::TaprootTweakDesc*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:signrpc.MuSig2SessionRequest.taproot_tweak)
}
inline ::signrpc::TaprootTweakDesc* MuSig2SessionRequest::release_taproot_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::signrpc::TaprootTweakDesc* released = _impl_.taproot_tweak_;
  _impl_.taproot_tweak_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::signrpc::TaprootTweakDesc* MuSig2SessionRequest::unsafe_arena_release_taproot_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2SessionRequest.taproot_tweak)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::signrpc::TaprootTweakDesc* temp = _impl_.taproot_tweak_;
  _impl_.taproot_tweak_ = nullptr;
  return temp;
}
inline ::signrpc::TaprootTweakDesc* MuSig2SessionRequest::_internal_mutable_taproot_tweak() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.taproot_tweak_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::signrpc::TaprootTweakDesc>(GetArena());
    _impl_.taproot_tweak_ = reinterpret_cast<::signrpc::TaprootTweakDesc*>(p);
  }
  return _impl_.taproot_tweak_;
}
inline ::signrpc::TaprootTweakDesc* MuSig2SessionRequest::mutable_taproot_tweak() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::signrpc::TaprootTweakDesc* _msg = _internal_mutable_taproot_tweak();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SessionRequest.taproot_tweak)
  return _msg;
}
inline void MuSig2SessionRequest::set_allocated_taproot_tweak(::signrpc::TaprootTweakDesc* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete (_impl_.taproot_tweak_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.taproot_tweak_ = reinterpret_cast<::signrpc::TaprootTweakDesc*>(value);
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2SessionRequest.taproot_tweak)
}

// .signrpc.MuSig2Version version = 6;
inline void MuSig2SessionRequest::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0;
}
inline ::signrpc::MuSig2Version MuSig2SessionRequest::version() const {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionRequest.version)
  return _internal_version();
}
inline void MuSig2SessionRequest::set_version(::signrpc::MuSig2Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SessionRequest.version)
}
inline ::signrpc::MuSig2Version MuSig2SessionRequest::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::signrpc::MuSig2Version>(_impl_.version_);
}
inline void MuSig2SessionRequest::_internal_set_version(::signrpc::MuSig2Version value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// bytes pregenerated_local_nonce = 7;
inline void MuSig2SessionRequest::clear_pregenerated_local_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pregenerated_local_nonce_.ClearToEmpty();
}
inline const std::string& MuSig2SessionRequest::pregenerated_local_nonce() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionRequest.pregenerated_local_nonce)
  return _internal_pregenerated_local_nonce();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2SessionRequest::set_pregenerated_local_nonce(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pregenerated_local_nonce_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SessionRequest.pregenerated_local_nonce)
}
inline std::string* MuSig2SessionRequest::mutable_pregenerated_local_nonce() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pregenerated_local_nonce();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SessionRequest.pregenerated_local_nonce)
  return _s;
}
inline const std::string& MuSig2SessionRequest::_internal_pregenerated_local_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pregenerated_local_nonce_.Get();
}
inline void MuSig2SessionRequest::_internal_set_pregenerated_local_nonce(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pregenerated_local_nonce_.Set(value, GetArena());
}
inline std::string* MuSig2SessionRequest::_internal_mutable_pregenerated_local_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pregenerated_local_nonce_.Mutable( GetArena());
}
inline std::string* MuSig2SessionRequest::release_pregenerated_local_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2SessionRequest.pregenerated_local_nonce)
  return _impl_.pregenerated_local_nonce_.Release();
}
inline void MuSig2SessionRequest::set_allocated_pregenerated_local_nonce(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pregenerated_local_nonce_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.pregenerated_local_nonce_.IsDefault()) {
          _impl_.pregenerated_local_nonce_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2SessionRequest.pregenerated_local_nonce)
}

// -------------------------------------------------------------------

// MuSig2SessionResponse

// bytes session_id = 1;
inline void MuSig2SessionResponse::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& MuSig2SessionResponse::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionResponse.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2SessionResponse::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SessionResponse.session_id)
}
inline std::string* MuSig2SessionResponse::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SessionResponse.session_id)
  return _s;
}
inline const std::string& MuSig2SessionResponse::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void MuSig2SessionResponse::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* MuSig2SessionResponse::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* MuSig2SessionResponse::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2SessionResponse.session_id)
  return _impl_.session_id_.Release();
}
inline void MuSig2SessionResponse::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2SessionResponse.session_id)
}

// bytes combined_key = 2;
inline void MuSig2SessionResponse::clear_combined_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combined_key_.ClearToEmpty();
}
inline const std::string& MuSig2SessionResponse::combined_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionResponse.combined_key)
  return _internal_combined_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2SessionResponse::set_combined_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combined_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SessionResponse.combined_key)
}
inline std::string* MuSig2SessionResponse::mutable_combined_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_combined_key();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SessionResponse.combined_key)
  return _s;
}
inline const std::string& MuSig2SessionResponse::_internal_combined_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.combined_key_.Get();
}
inline void MuSig2SessionResponse::_internal_set_combined_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combined_key_.Set(value, GetArena());
}
inline std::string* MuSig2SessionResponse::_internal_mutable_combined_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.combined_key_.Mutable( GetArena());
}
inline std::string* MuSig2SessionResponse::release_combined_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2SessionResponse.combined_key)
  return _impl_.combined_key_.Release();
}
inline void MuSig2SessionResponse::set_allocated_combined_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.combined_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.combined_key_.IsDefault()) {
          _impl_.combined_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2SessionResponse.combined_key)
}

// bytes taproot_internal_key = 3;
inline void MuSig2SessionResponse::clear_taproot_internal_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.taproot_internal_key_.ClearToEmpty();
}
inline const std::string& MuSig2SessionResponse::taproot_internal_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionResponse.taproot_internal_key)
  return _internal_taproot_internal_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2SessionResponse::set_taproot_internal_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.taproot_internal_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SessionResponse.taproot_internal_key)
}
inline std::string* MuSig2SessionResponse::mutable_taproot_internal_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_taproot_internal_key();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SessionResponse.taproot_internal_key)
  return _s;
}
inline const std::string& MuSig2SessionResponse::_internal_taproot_internal_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.taproot_internal_key_.Get();
}
inline void MuSig2SessionResponse::_internal_set_taproot_internal_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.taproot_internal_key_.Set(value, GetArena());
}
inline std::string* MuSig2SessionResponse::_internal_mutable_taproot_internal_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.taproot_internal_key_.Mutable( GetArena());
}
inline std::string* MuSig2SessionResponse::release_taproot_internal_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2SessionResponse.taproot_internal_key)
  return _impl_.taproot_internal_key_.Release();
}
inline void MuSig2SessionResponse::set_allocated_taproot_internal_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.taproot_internal_key_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.taproot_internal_key_.IsDefault()) {
          _impl_.taproot_internal_key_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2SessionResponse.taproot_internal_key)
}

// bytes local_public_nonces = 4;
inline void MuSig2SessionResponse::clear_local_public_nonces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_public_nonces_.ClearToEmpty();
}
inline const std::string& MuSig2SessionResponse::local_public_nonces() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionResponse.local_public_nonces)
  return _internal_local_public_nonces();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2SessionResponse::set_local_public_nonces(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_public_nonces_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SessionResponse.local_public_nonces)
}
inline std::string* MuSig2SessionResponse::mutable_local_public_nonces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_local_public_nonces();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SessionResponse.local_public_nonces)
  return _s;
}
inline const std::string& MuSig2SessionResponse::_internal_local_public_nonces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.local_public_nonces_.Get();
}
inline void MuSig2SessionResponse::_internal_set_local_public_nonces(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_public_nonces_.Set(value, GetArena());
}
inline std::string* MuSig2SessionResponse::_internal_mutable_local_public_nonces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.local_public_nonces_.Mutable( GetArena());
}
inline std::string* MuSig2SessionResponse::release_local_public_nonces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2SessionResponse.local_public_nonces)
  return _impl_.local_public_nonces_.Release();
}
inline void MuSig2SessionResponse::set_allocated_local_public_nonces(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_public_nonces_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.local_public_nonces_.IsDefault()) {
          _impl_.local_public_nonces_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2SessionResponse.local_public_nonces)
}

// bool have_all_nonces = 5;
inline void MuSig2SessionResponse::clear_have_all_nonces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.have_all_nonces_ = false;
}
inline bool MuSig2SessionResponse::have_all_nonces() const {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionResponse.have_all_nonces)
  return _internal_have_all_nonces();
}
inline void MuSig2SessionResponse::set_have_all_nonces(bool value) {
  _internal_set_have_all_nonces(value);
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SessionResponse.have_all_nonces)
}
inline bool MuSig2SessionResponse::_internal_have_all_nonces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.have_all_nonces_;
}
inline void MuSig2SessionResponse::_internal_set_have_all_nonces(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.have_all_nonces_ = value;
}

// .signrpc.MuSig2Version version = 6;
inline void MuSig2SessionResponse::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = 0;
}
inline ::signrpc::MuSig2Version MuSig2SessionResponse::version() const {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SessionResponse.version)
  return _internal_version();
}
inline void MuSig2SessionResponse::set_version(::signrpc::MuSig2Version value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SessionResponse.version)
}
inline ::signrpc::MuSig2Version MuSig2SessionResponse::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::signrpc::MuSig2Version>(_impl_.version_);
}
inline void MuSig2SessionResponse::_internal_set_version(::signrpc::MuSig2Version value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_ = value;
}

// -------------------------------------------------------------------

// MuSig2RegisterNoncesRequest

// bytes session_id = 1;
inline void MuSig2RegisterNoncesRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& MuSig2RegisterNoncesRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2RegisterNoncesRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2RegisterNoncesRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2RegisterNoncesRequest.session_id)
}
inline std::string* MuSig2RegisterNoncesRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2RegisterNoncesRequest.session_id)
  return _s;
}
inline const std::string& MuSig2RegisterNoncesRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void MuSig2RegisterNoncesRequest::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* MuSig2RegisterNoncesRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* MuSig2RegisterNoncesRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2RegisterNoncesRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void MuSig2RegisterNoncesRequest::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2RegisterNoncesRequest.session_id)
}

// repeated bytes other_signer_public_nonces = 3;
inline int MuSig2RegisterNoncesRequest::_internal_other_signer_public_nonces_size() const {
  return _internal_other_signer_public_nonces().size();
}
inline int MuSig2RegisterNoncesRequest::other_signer_public_nonces_size() const {
  return _internal_other_signer_public_nonces_size();
}
inline void MuSig2RegisterNoncesRequest::clear_other_signer_public_nonces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_signer_public_nonces_.Clear();
}
inline std::string* MuSig2RegisterNoncesRequest::add_other_signer_public_nonces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_other_signer_public_nonces()->Add();
  // @@protoc_insertion_point(field_add_mutable:signrpc.MuSig2RegisterNoncesRequest.other_signer_public_nonces)
  return _s;
}
inline const std::string& MuSig2RegisterNoncesRequest::other_signer_public_nonces(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2RegisterNoncesRequest.other_signer_public_nonces)
  return _internal_other_signer_public_nonces().Get(index);
}
inline std::string* MuSig2RegisterNoncesRequest::mutable_other_signer_public_nonces(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2RegisterNoncesRequest.other_signer_public_nonces)
  return _internal_mutable_other_signer_public_nonces()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void MuSig2RegisterNoncesRequest::set_other_signer_public_nonces(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_other_signer_public_nonces()->Mutable(index),
      std::forward<Arg_>(value), args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:signrpc.MuSig2RegisterNoncesRequest.other_signer_public_nonces)
}
template <typename Arg_, typename... Args_>
inline void MuSig2RegisterNoncesRequest::add_other_signer_public_nonces(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_other_signer_public_nonces(),
                               std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:signrpc.MuSig2RegisterNoncesRequest.other_signer_public_nonces)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MuSig2RegisterNoncesRequest::other_signer_public_nonces() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.MuSig2RegisterNoncesRequest.other_signer_public_nonces)
  return _internal_other_signer_public_nonces();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MuSig2RegisterNoncesRequest::mutable_other_signer_public_nonces() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.MuSig2RegisterNoncesRequest.other_signer_public_nonces)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_other_signer_public_nonces();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MuSig2RegisterNoncesRequest::_internal_other_signer_public_nonces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.other_signer_public_nonces_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MuSig2RegisterNoncesRequest::_internal_mutable_other_signer_public_nonces() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.other_signer_public_nonces_;
}

// -------------------------------------------------------------------

// MuSig2RegisterNoncesResponse

// bool have_all_nonces = 1;
inline void MuSig2RegisterNoncesResponse::clear_have_all_nonces() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.have_all_nonces_ = false;
}
inline bool MuSig2RegisterNoncesResponse::have_all_nonces() const {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2RegisterNoncesResponse.have_all_nonces)
  return _internal_have_all_nonces();
}
inline void MuSig2RegisterNoncesResponse::set_have_all_nonces(bool value) {
  _internal_set_have_all_nonces(value);
  // @@protoc_insertion_point(field_set:signrpc.MuSig2RegisterNoncesResponse.have_all_nonces)
}
inline bool MuSig2RegisterNoncesResponse::_internal_have_all_nonces() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.have_all_nonces_;
}
inline void MuSig2RegisterNoncesResponse::_internal_set_have_all_nonces(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.have_all_nonces_ = value;
}

// -------------------------------------------------------------------

// MuSig2SignRequest

// bytes session_id = 1;
inline void MuSig2SignRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& MuSig2SignRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SignRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2SignRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SignRequest.session_id)
}
inline std::string* MuSig2SignRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SignRequest.session_id)
  return _s;
}
inline const std::string& MuSig2SignRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void MuSig2SignRequest::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* MuSig2SignRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* MuSig2SignRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2SignRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void MuSig2SignRequest::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2SignRequest.session_id)
}

// bytes message_digest = 2;
inline void MuSig2SignRequest::clear_message_digest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_digest_.ClearToEmpty();
}
inline const std::string& MuSig2SignRequest::message_digest() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SignRequest.message_digest)
  return _internal_message_digest();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2SignRequest::set_message_digest(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_digest_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SignRequest.message_digest)
}
inline std::string* MuSig2SignRequest::mutable_message_digest() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_message_digest();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SignRequest.message_digest)
  return _s;
}
inline const std::string& MuSig2SignRequest::_internal_message_digest() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.message_digest_.Get();
}
inline void MuSig2SignRequest::_internal_set_message_digest(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_digest_.Set(value, GetArena());
}
inline std::string* MuSig2SignRequest::_internal_mutable_message_digest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.message_digest_.Mutable( GetArena());
}
inline std::string* MuSig2SignRequest::release_message_digest() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2SignRequest.message_digest)
  return _impl_.message_digest_.Release();
}
inline void MuSig2SignRequest::set_allocated_message_digest(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.message_digest_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.message_digest_.IsDefault()) {
          _impl_.message_digest_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2SignRequest.message_digest)
}

// bool cleanup = 3;
inline void MuSig2SignRequest::clear_cleanup() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cleanup_ = false;
}
inline bool MuSig2SignRequest::cleanup() const {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SignRequest.cleanup)
  return _internal_cleanup();
}
inline void MuSig2SignRequest::set_cleanup(bool value) {
  _internal_set_cleanup(value);
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SignRequest.cleanup)
}
inline bool MuSig2SignRequest::_internal_cleanup() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.cleanup_;
}
inline void MuSig2SignRequest::_internal_set_cleanup(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.cleanup_ = value;
}

// -------------------------------------------------------------------

// MuSig2SignResponse

// bytes local_partial_signature = 1;
inline void MuSig2SignResponse::clear_local_partial_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_partial_signature_.ClearToEmpty();
}
inline const std::string& MuSig2SignResponse::local_partial_signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2SignResponse.local_partial_signature)
  return _internal_local_partial_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2SignResponse::set_local_partial_signature(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_partial_signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2SignResponse.local_partial_signature)
}
inline std::string* MuSig2SignResponse::mutable_local_partial_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_local_partial_signature();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2SignResponse.local_partial_signature)
  return _s;
}
inline const std::string& MuSig2SignResponse::_internal_local_partial_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.local_partial_signature_.Get();
}
inline void MuSig2SignResponse::_internal_set_local_partial_signature(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_partial_signature_.Set(value, GetArena());
}
inline std::string* MuSig2SignResponse::_internal_mutable_local_partial_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.local_partial_signature_.Mutable( GetArena());
}
inline std::string* MuSig2SignResponse::release_local_partial_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2SignResponse.local_partial_signature)
  return _impl_.local_partial_signature_.Release();
}
inline void MuSig2SignResponse::set_allocated_local_partial_signature(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.local_partial_signature_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.local_partial_signature_.IsDefault()) {
          _impl_.local_partial_signature_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2SignResponse.local_partial_signature)
}

// -------------------------------------------------------------------

// MuSig2CombineSigRequest

// bytes session_id = 1;
inline void MuSig2CombineSigRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& MuSig2CombineSigRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineSigRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2CombineSigRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2CombineSigRequest.session_id)
}
inline std::string* MuSig2CombineSigRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2CombineSigRequest.session_id)
  return _s;
}
inline const std::string& MuSig2CombineSigRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void MuSig2CombineSigRequest::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* MuSig2CombineSigRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* MuSig2CombineSigRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2CombineSigRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void MuSig2CombineSigRequest::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2CombineSigRequest.session_id)
}

// repeated bytes other_partial_signatures = 2;
inline int MuSig2CombineSigRequest::_internal_other_partial_signatures_size() const {
  return _internal_other_partial_signatures().size();
}
inline int MuSig2CombineSigRequest::other_partial_signatures_size() const {
  return _internal_other_partial_signatures_size();
}
inline void MuSig2CombineSigRequest::clear_other_partial_signatures() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.other_partial_signatures_.Clear();
}
inline std::string* MuSig2CombineSigRequest::add_other_partial_signatures() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_other_partial_signatures()->Add();
  // @@protoc_insertion_point(field_add_mutable:signrpc.MuSig2CombineSigRequest.other_partial_signatures)
  return _s;
}
inline const std::string& MuSig2CombineSigRequest::other_partial_signatures(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineSigRequest.other_partial_signatures)
  return _internal_other_partial_signatures().Get(index);
}
inline std::string* MuSig2CombineSigRequest::mutable_other_partial_signatures(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2CombineSigRequest.other_partial_signatures)
  return _internal_mutable_other_partial_signatures()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void MuSig2CombineSigRequest::set_other_partial_signatures(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_other_partial_signatures()->Mutable(index),
      std::forward<Arg_>(value), args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_set:signrpc.MuSig2CombineSigRequest.other_partial_signatures)
}
template <typename Arg_, typename... Args_>
inline void MuSig2CombineSigRequest::add_other_partial_signatures(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_other_partial_signatures(),
                               std::forward<Arg_>(value),
                               args... , ::google::protobuf::internal::BytesTag{});
  // @@protoc_insertion_point(field_add:signrpc.MuSig2CombineSigRequest.other_partial_signatures)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MuSig2CombineSigRequest::other_partial_signatures() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:signrpc.MuSig2CombineSigRequest.other_partial_signatures)
  return _internal_other_partial_signatures();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MuSig2CombineSigRequest::mutable_other_partial_signatures() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:signrpc.MuSig2CombineSigRequest.other_partial_signatures)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_other_partial_signatures();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
MuSig2CombineSigRequest::_internal_other_partial_signatures() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.other_partial_signatures_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
MuSig2CombineSigRequest::_internal_mutable_other_partial_signatures() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.other_partial_signatures_;
}

// -------------------------------------------------------------------

// MuSig2CombineSigResponse

// bool have_all_signatures = 1;
inline void MuSig2CombineSigResponse::clear_have_all_signatures() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.have_all_signatures_ = false;
}
inline bool MuSig2CombineSigResponse::have_all_signatures() const {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineSigResponse.have_all_signatures)
  return _internal_have_all_signatures();
}
inline void MuSig2CombineSigResponse::set_have_all_signatures(bool value) {
  _internal_set_have_all_signatures(value);
  // @@protoc_insertion_point(field_set:signrpc.MuSig2CombineSigResponse.have_all_signatures)
}
inline bool MuSig2CombineSigResponse::_internal_have_all_signatures() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.have_all_signatures_;
}
inline void MuSig2CombineSigResponse::_internal_set_have_all_signatures(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.have_all_signatures_ = value;
}

// bytes final_signature = 2;
inline void MuSig2CombineSigResponse::clear_final_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_signature_.ClearToEmpty();
}
inline const std::string& MuSig2CombineSigResponse::final_signature() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CombineSigResponse.final_signature)
  return _internal_final_signature();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2CombineSigResponse::set_final_signature(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_signature_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2CombineSigResponse.final_signature)
}
inline std::string* MuSig2CombineSigResponse::mutable_final_signature() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_final_signature();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2CombineSigResponse.final_signature)
  return _s;
}
inline const std::string& MuSig2CombineSigResponse::_internal_final_signature() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.final_signature_.Get();
}
inline void MuSig2CombineSigResponse::_internal_set_final_signature(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_signature_.Set(value, GetArena());
}
inline std::string* MuSig2CombineSigResponse::_internal_mutable_final_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.final_signature_.Mutable( GetArena());
}
inline std::string* MuSig2CombineSigResponse::release_final_signature() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2CombineSigResponse.final_signature)
  return _impl_.final_signature_.Release();
}
inline void MuSig2CombineSigResponse::set_allocated_final_signature(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.final_signature_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.final_signature_.IsDefault()) {
          _impl_.final_signature_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2CombineSigResponse.final_signature)
}

// -------------------------------------------------------------------

// MuSig2CleanupRequest

// bytes session_id = 1;
inline void MuSig2CleanupRequest::clear_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.ClearToEmpty();
}
inline const std::string& MuSig2CleanupRequest::session_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:signrpc.MuSig2CleanupRequest.session_id)
  return _internal_session_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void MuSig2CleanupRequest::set_session_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:signrpc.MuSig2CleanupRequest.session_id)
}
inline std::string* MuSig2CleanupRequest::mutable_session_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:signrpc.MuSig2CleanupRequest.session_id)
  return _s;
}
inline const std::string& MuSig2CleanupRequest::_internal_session_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.session_id_.Get();
}
inline void MuSig2CleanupRequest::_internal_set_session_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.Set(value, GetArena());
}
inline std::string* MuSig2CleanupRequest::_internal_mutable_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.session_id_.Mutable( GetArena());
}
inline std::string* MuSig2CleanupRequest::release_session_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:signrpc.MuSig2CleanupRequest.session_id)
  return _impl_.session_id_.Release();
}
inline void MuSig2CleanupRequest::set_allocated_session_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.session_id_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.session_id_.IsDefault()) {
          _impl_.session_id_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:signrpc.MuSig2CleanupRequest.session_id)
}

// -------------------------------------------------------------------

// MuSig2CleanupResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace signrpc


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::signrpc::SignMethod> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::signrpc::SignMethod>() {
  return ::signrpc::SignMethod_descriptor();
}
template <>
struct is_proto_enum<::signrpc::MuSig2Version> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::signrpc::MuSig2Version>() {
  return ::signrpc::MuSig2Version_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_signer_2eproto_2epb_2eh
